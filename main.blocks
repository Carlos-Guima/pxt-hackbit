<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="$m;gB:*$ub$doD7qFwm%" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="#`YHr9uyJc:sOr#=.WEk" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace hackbit {" line1="    const initRegisterArray: number[] = [" line2="        0xEF, 0x00, 0x32, 0x29, 0x33, 0x01, 0x34, 0x00, 0x35, 0x01, 0x36, 0x00, 0x37, 0x07, 0x38, 0x17," line3="        0x39, 0x06, 0x3A, 0x12, 0x3F, 0x00, 0x40, 0x02, 0x41, 0xFF, 0x42, 0x01, 0x46, 0x2D, 0x47, 0x0F," line4="        0x48, 0x3C, 0x49, 0x00, 0x4A, 0x1E, 0x4B, 0x00, 0x4C, 0x20, 0x4D, 0x00, 0x4E, 0x1A, 0x4F, 0x14," line5="        0x50, 0x00, 0x51, 0x10, 0x52, 0x00, 0x5C, 0x02, 0x5D, 0x00, 0x5E, 0x10, 0x5F, 0x3F, 0x60, 0x27," line6="        0x61, 0x28, 0x62, 0x00, 0x63, 0x03, 0x64, 0xF7, 0x65, 0x03, 0x66, 0xD9, 0x67, 0x03, 0x68, 0x01," line7="        0x69, 0xC8, 0x6A, 0x40, 0x6D, 0x04, 0x6E, 0x00, 0x6F, 0x00, 0x70, 0x80, 0x71, 0x00, 0x72, 0x00," line8="        0x73, 0x00, 0x74, 0xF0, 0x75, 0x00, 0x80, 0x42, 0x81, 0x44, 0x82, 0x04, 0x83, 0x20, 0x84, 0x20," line9="        0x85, 0x00, 0x86, 0x10, 0x87, 0x00, 0x88, 0x05, 0x89, 0x18, 0x8A, 0x10, 0x8B, 0x01, 0x8C, 0x37," line10="        0x8D, 0x00, 0x8E, 0xF0, 0x8F, 0x81, 0x90, 0x06, 0x91, 0x06, 0x92, 0x1E, 0x93, 0x0D, 0x94, 0x0A," line11="        0x95, 0x0A, 0x96, 0x0C, 0x97, 0x05, 0x98, 0x0A, 0x99, 0x41, 0x9A, 0x14, 0x9B, 0x0A, 0x9C, 0x3F," line12="        0x9D, 0x33, 0x9E, 0xAE, 0x9F, 0xF9, 0xA0, 0x48, 0xA1, 0x13, 0xA2, 0x10, 0xA3, 0x08, 0xA4, 0x30," line13="        0xA5, 0x19, 0xA6, 0x10, 0xA7, 0x08, 0xA8, 0x24, 0xA9, 0x04, 0xAA, 0x1E, 0xAB, 0x1E, 0xCC, 0x19," line14="        0xCD, 0x0B, 0xCE, 0x13, 0xCF, 0x64, 0xD0, 0x21, 0xD1, 0x0F, 0xD2, 0x88, 0xE0, 0x01, 0xE1, 0x04," line15="        0xE2, 0x41, 0xE3, 0xD6, 0xE4, 0x00, 0xE5, 0x0C, 0xE6, 0x0A, 0xE7, 0x00, 0xE8, 0x00, 0xE9, 0x00," line16="        0xEE, 0x07, 0xEF, 0x01, 0x00, 0x1E, 0x01, 0x1E, 0x02, 0x0F, 0x03, 0x10, 0x04, 0x02, 0x05, 0x00," line17="        0x06, 0xB0, 0x07, 0x04, 0x08, 0x0D, 0x09, 0x0E, 0x0A, 0x9C, 0x0B, 0x04, 0x0C, 0x05, 0x0D, 0x0F," line18="        0x0E, 0x02, 0x0F, 0x12, 0x10, 0x02, 0x11, 0x02, 0x12, 0x00, 0x13, 0x01, 0x14, 0x05, 0x15, 0x07," line19="        0x16, 0x05, 0x17, 0x07, 0x18, 0x01, 0x19, 0x04, 0x1A, 0x05, 0x1B, 0x0C, 0x1C, 0x2A, 0x1D, 0x01," line20="        0x1E, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x25, 0x01, 0x26, 0x00, 0x27, 0x39, 0x28, 0x7F," line21="        0x29, 0x08, 0x30, 0x03, 0x31, 0x00, 0x32, 0x1A, 0x33, 0x1A, 0x34, 0x07, 0x35, 0x07, 0x36, 0x01," line22="        0x37, 0xFF, 0x38, 0x36, 0x39, 0x07, 0x3A, 0x00, 0x3E, 0xFF, 0x3F, 0x00, 0x40, 0x77, 0x41, 0x40," line23="        0x42, 0x00, 0x43, 0x30, 0x44, 0xA0, 0x45, 0x5C, 0x46, 0x00, 0x47, 0x00, 0x48, 0x58, 0x4A, 0x1E," line24="        0x4B, 0x1E, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0xA0, 0x4F, 0x80, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00," line25="        0x53, 0x00, 0x54, 0x00, 0x57, 0x80, 0x59, 0x10, 0x5A, 0x08, 0x5B, 0x94, 0x5C, 0xE8, 0x5D, 0x08," line26="        0x5E, 0x3D, 0x5F, 0x99, 0x60, 0x45, 0x61, 0x40, 0x63, 0x2D, 0x64, 0x02, 0x65, 0x96, 0x66, 0x00," line27="        0x67, 0x97, 0x68, 0x01, 0x69, 0xCD, 0x6A, 0x01, 0x6B, 0xB0, 0x6C, 0x04, 0x6D, 0x2C, 0x6E, 0x01," line28="        0x6F, 0x32, 0x71, 0x00, 0x72, 0x01, 0x73, 0x35, 0x74, 0x00, 0x75, 0x33, 0x76, 0x31, 0x77, 0x01," line29="        0x7C, 0x84, 0x7D, 0x03, 0x7E, 0x01" line30="    ];" line31="" line32="/**" line33="* Sempre adicionar ao inicio de main.ts antes de submeter" line34="* //% color=#FF1344 icon=&quot;\uf135&quot;" line35="* //% block=&quot;Hackbit&quot; blockId=&quot;hackbit&quot;" line36="**/" line37="" line38="    export enum MotorDirection {" line39="        //% block=&quot;Forward&quot;" line40="        Forward = 1," line41="        //% block=&quot;Backward&quot;" line42="        Reverse = 2," line43="        //% block=&quot;Stop&quot;" line44="        Stop = 0" line45="    }" line46="" line47="    export enum OnOff {" line48="        //% block=&quot;On&quot;" line49="        On = 1," line50="        //% block=&quot;Off&quot;" line51="        Off = 0" line52="    }" line53="" line54="    export enum BP {" line55="        //% block=&quot;BPA&quot;" line56="        BPA = 1," line57="        //% block=&quot;BPB&quot;" line58="        BPB = 0" line59="    }" line60="" line61="    export enum RobotDirection {" line62="        //% block=&quot;Forward&quot;" line63="        Forward," line64="        //% block=&quot;Backward&quot;" line65="        Reverse," line66="        //% block=&quot;Turn Right&quot;" line67="        TurnRigh," line68="        //% block=&quot;Turn Left&quot;" line69="        TurnLef," line70="        //% block=&quot;Rotate Right&quot;" line71="        RotateRight," line72="        //% block=&quot;Rotate Left&quot;" line73="        RotateLef," line74="        //% block=&quot;Stop&quot;" line75="        Stop" line76="    }" line77="" line78="    export enum Motors {" line79="        //%blockId=A4_Robot_Driver_motor_one" line80="        //% block=&quot;left motor&quot;" line81="        Motor1," line82="        //%blockId=A4_Robot_Driver_motor_two" line83="        //% block=&quot;right motor&quot;" line84="        Motor2," line85="        //%blockId=A4_Robot_Driver_motor_full" line86="        //% block=&quot;left and right motor&quot;" line87="        MotorFull" line88="    }" line89="" line90="    export enum Color {" line91="        //% block=&quot;Red&quot;" line92="        Red," line93="        //% block=&quot;Green&quot;" line94="        Green," line95="        //% block=&quot;Blue&quot;" line96="        Blue," line97="        //% block=&quot;Clear&quot;" line98="        Clear" line99="    }" line100="" line101="    export enum GroveGesture {" line102="        //% block=None" line103="        None = 0," line104="        //% block=Right" line105="        Right = 1," line106="        //% block=Left" line107="        Left = 2," line108="        //% block=Up" line109="        Up = 3," line110="        //% block=Down" line111="        Down = 4," line112="        //% block=Forward" line113="        Forward = 5," line114="        //% block=Backward" line115="        Backward = 6," line116="        //% block=Clockwise" line117="        Clockwise = 7," line118="        //% block=Anticlockwise" line119="        Anticlockwise = 8," line120="        //% block=Wave" line121="        Wave = 9" line122="    }" line123="" line124="    export let _speed_left = 700; //1023 = 100% speed" line125="    export let _speed_right = 700;" line126="    export let _dir_right = 1; //0 = stop, 1 = forward, 2 = backward" line127="    export let _dir_left = 1;" line128="    export let identifiant = 0;" line129="    export let grovegestureinit = 0;" line130="" line131="    let TubeTab: number[] = [" line132="        0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07," line133="        0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71" line134="    ];" line135="" line136="    export let digit_clkPin: DigitalPin;" line137="    export let digit_dataPin: DigitalPin;" line138="    export let digit_brightnessLevel: number;" line139="    export let digit_pointFlag: boolean;" line140="    export let digit_buf: Buffer;" line141="" line142="    /**" line143="     * Iot ThingSpeak" line144="    **/" line145="    " line146="    let wifi_connected: boolean = false" line147="    let thingspeak_connected: boolean = false" line148="    let last_upload_successful: boolean = false" line149="" line150="" line151="    /**" line152="     * Control Robot speed [0-100%]" line153="     * @param dir direction" line154="     * @param speed speed in %" line155="     */" line156="    //% blockId=RobotDriverRobotMove" line157="    //% block=&quot;move %dir| speed %speed&quot;" line158="    //% speed.min=0 speed.max=100" line159="    //% parts=&quot;RobotDriver&quot; advanced=false" line160="    //% speed.defl=75" line161="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#FF1344 icon=&quot;\uf1eb&quot;" line162="    export function robotMove(dir: RobotDirection, speed: number): void {" line163="        setSpeed(Motors.MotorFull, speed);" line164="        switch (dir) {" line165="            case RobotDirection.Forward:" line166="                setDir(Motors.MotorFull, MotorDirection.Forward);" line167="                break" line168="            case RobotDirection.Reverse:" line169="                setDir(Motors.MotorFull, MotorDirection.Reverse);" line170="                break" line171="            case RobotDirection.RotateRight:" line172="                setDir(Motors.Motor1, MotorDirection.Forward);" line173="                setDir(Motors.Motor2, MotorDirection.Reverse);" line174="                break" line175="            case RobotDirection.RotateLef:" line176="                setDir(Motors.Motor1, MotorDirection.Reverse);" line177="                setDir(Motors.Motor2, MotorDirection.Forward);" line178="                break" line179="            case RobotDirection.TurnRigh:" line180="                setDir(Motors.Motor1, MotorDirection.Forward);" line181="                setDir(Motors.Motor2, MotorDirection.Stop);" line182="                break" line183="            case RobotDirection.TurnLef:" line184="                setDir(Motors.Motor1, MotorDirection.Stop);" line185="                setDir(Motors.Motor2, MotorDirection.Forward);" line186="                break" line187="            case RobotDirection.Stop:" line188="                setDir(Motors.MotorFull, MotorDirection.Stop);" line189="                break" line190="        }" line191="        setMotors();" line192="    }" line193="" line194="" line195="    /**" line196="     * Change the motor direction" line197="     * @param motor selection (left, right)" line198="     * @param dir rotation direction (forward, backward)" line199="     */" line200="    //% blockId=RobotDrivermotordir" line201="    //% block=&quot;set %motor| %dir&quot;" line202="    //% parts=&quot;RobotDriver&quot; advanced=false" line203="    //% motor.defl=MotorFull" line204="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#FF1344 icon=&quot;\uf1eb&quot;" line205="    export function motorDir(motor: Motors, dir: MotorDirection): void {" line206="        setDir(motor, dir);" line207="        setMotors();" line208="    }" line209="" line210="    /**" line211="     * Change the motor speed [0-100%]" line212="     * @param motor selection (left, right)" line213="     * @param new speed (0-100%)" line214="     */" line215="" line216="    //% blockId=robotdrivermotorspeed" line217="    //% block=&quot;set %motor| to %speed %&quot;" line218="    //% speed.min=0 speed.max=100" line219="    //% parts=&quot;A4_Robot_Driver&quot; advanced=false" line220="    //% speed.defl=75" line221="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#FF1344 icon=&quot;\uf1eb&quot;" line222="    export function motorSpeed(motor: Motors, speed: number): void {" line223="        setSpeed(motor, speed);" line224="        setMotors();" line225="    }" line226="" line227="    /**" line228="     * Stop both motors" line229="    */" line230="    //% blockId=RobotDriverRobotStop" line231="    //% block=&quot;stop both motors&quot;" line232="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#FF1344 icon=&quot;\uf1eb&quot;" line233="    export function motorStop(): void {" line234="        robotMove(hackbit.RobotDirection.Stop, 0)" line235="    }" line236="" line237="    /**" line238="     * Set the servomotor position [0-180deg]" line239="     * @param pin servomotor pin (right or left)" line240="     */" line241="    //% blockId=RobotDriverservodegrees" line242="    //% block=&quot;servomotor |%pin| to |%angle| degree&quot;" line243="    //% parts=&quot;RobotDriver&quot; advanced=false" line244="    //% angle.shadow=&quot;protractorPicker&quot;" line245="    //% angle.defl=90" line246="    //% subcategory=Motor  group=&quot;Servo Motors&quot; color=#FF1344 icon=&quot;\uf1eb&quot;" line247="    export function setServoMotor(pin: AnalogPin, angle: number): void {" line248="        pins.servoWritePin(pin, Math.constrain(angle, 0, 180));" line249="    }" line250="" line251="    /**" line252="     * get distance from ultrasonic range sensor [cm]" line253="     * @param pin Input pin" line254="     */" line255="    //% blockId=RobotDriverultrasonic_cm " line256="    //% block=&quot;ultrasonic distance|%name| (cm)&quot;" line257="    //% name.fieldEditor=&quot;gridpicker&quot; " line258="    //% name.fieldOptions.columns=5" line259="    //% name.fieldOptions.tooltips=&quot;false&quot;" line260="    //% name.fieldOptions.width=&quot;0&quot;" line261="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;" line262="    export function measureDistanceCentimeter(name: DigitalPin): number {" line263="        let duration = 0;" line264="        let distance = 0;" line265="        pins.digitalWritePin(name, 0); //make sure pin is low" line266="        control.waitMicros(2);" line267="        pins.digitalWritePin(name, 1); //send echo" line268="        control.waitMicros(20);" line269="        pins.digitalWritePin(name, 0);" line270="        duration = pins.pulseIn(name, PulseValue.High, 50000); // Max duration 50 ms - receive echo" line271="        distance = duration * 153 / 29 / 2 / 100;" line272="        Math.constrain(distance, 0, 500);" line273="        return distance;" line274="    }" line275="" line276="    /**" line277="     * Get line sensor state [0-1]" line278="    */" line279="    //% blockId=hackbitLineRead" line280="    //% block=&quot;line sensor |%pin|&quot;" line281="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line282="    export function detectline(pin: DigitalPin): number {" line283="        return pins.digitalReadPin(pin);" line284="    }" line285="" line286="    /**" line287="     * Get analog potentiometer value [0-1023]" line288="    */" line289="    //% blockId=hackbitPotargRead" line290="    //% block=&quot;potentiometer |%pin|&quot;" line291="    //% subcategory=Input  group=&quot;Analog&quot; color=#851DE8 icon=&quot;\uf1eb&quot;" line292="    export function potarValue(pin: AnalogPin): number {" line293="        return pins.analogReadPin(pin);" line294="    }" line295="" line296="    /**" line297="     * Get collision sensor state [0-1]" line298="    */" line299="    //% blockId=hackbitCollisionRead" line300="    //% block=&quot;collision sensor |%pin|&quot;" line301="    //% subcategory=Input  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line302="    export function collisionSensor(pin: BP): boolean {" line303="        if (pin)" line304="            return input.buttonIsPressed(Button.A);" line305="        return input.buttonIsPressed(Button.B);" line306="    }" line307="" line308="    /**" line309="     * Get button state [0-1]" line310="    */" line311="    //% blockId=hackbitButtonRead" line312="    //% block=&quot;button |%pin|&quot;" line313="    //% subcategory=Input  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line314="    export function buttonState(pin: DigitalPin): number {" line315="        return pins.digitalReadPin(pin);" line316="    }" line317="" line318="    /**" line319="     * Set Led state" line320="    */" line321="    //% blockId=hackbitLedSet" line322="    //% block=&quot;led |%pin| to |%state|&quot;" line323="    //% state.min=0 state.max=1" line324="    //% subcategory=Display  group=&quot;Digital&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line325="    export function ledState(pin: DigitalPin, state: OnOff): void {" line326="        pins.digitalWritePin(pin, state);" line327="    }" line328="" line329="    /**" line330="    * Get color from I2C Grove Color Sensor v1.3 or v2.0" line331="    * [0;65534]" line332="    * @param selected color" line333="    */" line334="    //% blockId=&quot;grovecolorsensorgetcolor&quot; " line335="    //% block=&quot;color %Color&quot;" line336="    //% block.loc.fr=&quot;Valeur de la couleur %Color du capteur de couleur grove&quot;" line337="    //% jsdoc = &quot;Grab sensor value from grove color sensor&quot;" line338="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line339="" line340="    export function color(col: Color): NumberFormat.UInt16BE {" line341="        let nums, red, green, blue, clear: number;" line342="" line343="        if (identifiant == 0) {   // No sensor previously detected" line344="            pins.i2cWriteNumber(57, 132, NumberFormat.UInt8BE, false);" line345="            nums = pins.i2cReadNumber(57, NumberFormat.UInt8BE, false);" line346="            if (nums == 17) {     // Grove Sensor v1.3 detected" line347="                identifiant = 1;" line348="                pins.i2cWriteNumber(57, 129, NumberFormat.UInt8BE, false);" line349="                pins.i2cWriteNumber(57, 0, NumberFormat.UInt8BE, true);" line350="                pins.i2cWriteNumber(57, 135, NumberFormat.UInt8BE, false);" line351="                pins.i2cWriteNumber(57, 48, NumberFormat.UInt8BE, true);" line352="                pins.i2cWriteNumber(57, 128, NumberFormat.UInt8BE, false);" line353="                pins.i2cWriteNumber(57, 3, NumberFormat.UInt8BE, true);" line354="                basic.pause(50);" line355="            } else {" line356="                pins.i2cWriteNumber(41, 146, NumberFormat.UInt8BE, false);" line357="                nums = pins.i2cReadNumber(41, NumberFormat.UInt8BE, false);" line358="                if (nums == 68) {     // Grove Sensor v2 detected " line359="                    identifiant = 2;" line360="                    pins.i2cWriteNumber(41, 129, NumberFormat.UInt8BE, false);" line361="                    pins.i2cWriteNumber(41, 249, NumberFormat.UInt8BE, true);" line362="                    pins.i2cWriteNumber(41, 143, NumberFormat.UInt8BE, false);" line363="                    pins.i2cWriteNumber(41, 2, NumberFormat.UInt8BE, true);" line364="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line365="                    pins.i2cWriteNumber(41, 1, NumberFormat.UInt8BE, true);" line366="                    basic.pause(50);" line367="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line368="                    pins.i2cWriteNumber(41, 3, NumberFormat.UInt8BE, true);" line369="                    basic.pause(500);" line370="                }" line371="            }" line372="        }" line373="" line374="        if (identifiant == 1) {    // Grove Sensor v1.3 detected" line375="            switch (col) {" line376="                case Color.Red:" line377="                    pins.i2cWriteNumber(57, 210, NumberFormat.UInt8BE, false);" line378="                    red = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line379="                    return swap16(red)" line380="                    break" line381="                case Color.Green:" line382="                    pins.i2cWriteNumber(57, 208, NumberFormat.UInt8BE, false);" line383="                    green = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line384="                    return swap16(green)" line385="                    break" line386="                case Color.Blue:" line387="                    pins.i2cWriteNumber(57, 212, NumberFormat.UInt8BE, false);" line388="                    blue = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line389="                    return swap16(blue)" line390="                    break" line391="                case Color.Clear:" line392="                    pins.i2cWriteNumber(57, 214, NumberFormat.UInt8BE, false);" line393="                    clear = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line394="                    return swap16(clear)" line395="                    break" line396="            }" line397="        }" line398="        else if (identifiant == 2) {" line399="            switch (col) {" line400="                case Color.Red:" line401="                    pins.i2cWriteNumber(41, 150, NumberFormat.UInt8BE, false);" line402="                    red = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line403="                    return swap16(red)" line404="                    break" line405="                case Color.Green:" line406="                    pins.i2cWriteNumber(41, 152, NumberFormat.UInt8BE, false);" line407="                    green = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line408="                    return swap16(green)" line409="                    break" line410="                case Color.Blue:" line411="                    pins.i2cWriteNumber(41, 154, NumberFormat.UInt8BE, false);" line412="                    blue = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line413="                    return swap16(blue)" line414="                    break" line415="                case Color.Clear:" line416="                    pins.i2cWriteNumber(41, 148, NumberFormat.UInt8BE, false);" line417="                    clear = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line418="                    return swap16(clear)" line419="                    break" line420="            }" line421="            return 0;" line422="        }" line423="        return 0;" line424="    }" line425="" line426="    /**" line427="     * Detect and recognize the gestures from Grove - Gesture" line428="     * None:0" line429="     * Right:1" line430="     * Left:2" line431="     * Up:3" line432="     * Down:4" line433="     * Forward:5" line434="     * Backward:6" line435="     * Clockwise:7" line436="     * Anticlockwise:8" line437="     * Wave:9" line438="     */" line439="    //% blockId=hackbitGroveGesture" line440="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line441="    export function grove_gesture_reads(): number {" line442="        let data = 0, result = 0;" line443="" line444="        if (grovegestureinit == 0) {" line445="            paj7620Init();" line446="            basic.pause(200);" line447="            grovegestureinit = 1;" line448="        }" line449="" line450="        data = paj7620ReadReg(0x43);" line451="        switch (data) {" line452="            case 0x01:" line453="                result = GroveGesture.Right;" line454="                break;" line455="" line456="            case 0x02:" line457="                result = GroveGesture.Left;" line458="                break;" line459="" line460="            case 0x04:" line461="                result = GroveGesture.Up;" line462="                break;" line463="" line464="            case 0x08:" line465="                result = GroveGesture.Down;" line466="                break;" line467="" line468="            case 0x10:" line469="                result = GroveGesture.Forward;" line470="                break;" line471="" line472="            case 0x20:" line473="                result = GroveGesture.Backward;" line474="                break;" line475="" line476="            case 0x40:" line477="                result = GroveGesture.Clockwise;" line478="                break;" line479="" line480="            case 0x80:" line481="                result = GroveGesture.Anticlockwise;" line482="                break;" line483="" line484="            default:" line485="                data = paj7620ReadReg(0x44);" line486="                if (data == 0x01)" line487="                    result = GroveGesture.Wave;" line488="                break;" line489="        }" line490="        return result;" line491="    }" line492="" line493="    /**" line494="     * Create a new driver Grove - 4-Digit Display" line495="     * @param clkPin value of clk pin number" line496="     * @param dataPin value of data pin number" line497="     */" line498="    //% blockId=hackbit_tm1637_create block=&quot;4-Digit Display at|%clkPin|and|%dataPin&quot;" line499="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line500="    //% weight=60" line501="    export function digit_createDisplay(clkPin: DigitalPin, dataPin: DigitalPin): void {" line502="        digit_buf = pins.createBuffer(4);" line503="        digit_clkPin = clkPin;" line504="        digit_dataPin = dataPin;" line505="        digit_brightnessLevel = 0;" line506="        digit_pointFlag = false;" line507="        digit_clear();" line508="    }" line509="" line510="    /**" line511="    * Show a 4 digits number on display" line512="    * @param dispData value of number" line513="    */" line514="    //% blockId=hackbit_tm1637_display_number block=&quot;show number|%dispData&quot;" line515="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line516="    //% weight=59" line517="    export function digit_show(dispData: number) {" line518="        let compare_01: number = dispData % 100;" line519="        let compare_001: number = dispData % 1000;" line520="" line521="        if (dispData &lt; 10) {" line522="            digit_bit(dispData, 3);" line523="            digit_bit(0x7f, 2);" line524="            digit_bit(0x7f, 1);" line525="            digit_bit(0x7f, 0);" line526="        }" line527="        else if (dispData &lt; 100) {" line528="            digit_bit(dispData % 10, 3);" line529="            if (dispData &gt; 90) {" line530="                digit_bit(9, 2);" line531="            } else {" line532="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line533="            }" line534="" line535="            digit_bit(0x7f, 1);" line536="            digit_bit(0x7f, 0);" line537="        }" line538="        else if (dispData &lt; 1000) {" line539="            digit_bit(dispData % 10, 3);" line540="            if (compare_01 &gt; 90) {" line541="                digit_bit(9, 2);" line542="            } else {" line543="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line544="            }" line545="            if (compare_001 &gt; 900) {" line546="                digit_bit(9, 1);" line547="            } else {" line548="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line549="            }" line550="            digit_bit(0x7f, 0);" line551="        }" line552="        else if (dispData &lt; 10000) {" line553="            digit_bit(dispData % 10, 3);" line554="            if (compare_01 &gt; 90) {" line555="                digit_bit(9, 2);" line556="            } else {" line557="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line558="            }" line559="            if (compare_001 &gt; 900) {" line560="                digit_bit(9, 1);" line561="            } else {" line562="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line563="            }" line564="            if (dispData &gt; 9000) {" line565="                digit_bit(9, 0);" line566="            } else {" line567="                digit_bit(Math.floor(dispData / 1000) % 10, 0);" line568="            }" line569="        }" line570="        else {" line571="            digit_bit(9, 3);" line572="            digit_bit(9, 2);" line573="            digit_bit(9, 1);" line574="            digit_bit(9, 0);" line575="        }" line576="    }" line577="" line578="    /**" line579="     * Set the brightness level of display at from 0 to 7" line580="     * @param level value of brightness light level" line581="     */" line582="    //% blockId=hackbit_tm1637_set_display_level block=&quot;brightness level to|%level&quot;" line583="    //% level.min=0 level.max=7" line584="    //% weight=58" line585="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;     " line586="    export function digit_set(level: number) {" line587="        digit_brightnessLevel = level;" line588="" line589="        digit_bit(digit_buf[0], 0x00);" line590="        digit_bit(digit_buf[1], 0x01);" line591="        digit_bit(digit_buf[2], 0x02);" line592="        digit_bit(digit_buf[3], 0x03);" line593="    }" line594="" line595="    /**" line596="     * Show a single number from 0 to 9 at a specified digit of Grove - 4-Digit Display" line597="     * @param dispData value of number" line598="     * @param bitAddr value of bit number" line599="     */" line600="    //% blockId=grove_tm1637_display_bit block=&quot;%strip|show single number|%dispData|at digit|%bitAddr&quot;" line601="    //% dispData.min=0 dispData.max=9" line602="    //% bitAddr.min=0 bitAddr.max=3" line603="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line604="    //% advanced=false" line605="    export function digit_bit(dispData: number, bitAddr: number) {" line606="        if ((dispData == 0x7f) || ((dispData &lt;= 9) &amp;&amp; (bitAddr &lt;= 3))) {" line607="            let segData = 0;" line608="" line609="            segData = digit_coding(dispData);" line610="            digit_start();" line611="            digit_writeByte(0x44);" line612="            digit_stop();" line613="            digit_start();" line614="            digit_writeByte(bitAddr | 0xc0);" line615="            digit_writeByte(segData);" line616="            digit_stop();" line617="            digit_start();" line618="            digit_writeByte(0x88 + digit_brightnessLevel);" line619="            digit_stop();" line620="" line621="            digit_buf[bitAddr] = dispData;" line622="        }" line623="    }" line624="" line625="    /**" line626="     * Turn on or off the colon point on Grove - 4-Digit Display" line627="     * @param pointEn value of point switch" line628="     */" line629="    //% blockId=grove_tm1637_display_point block=&quot;%strip|turn|%point|colon point&quot;" line630="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;   " line631="    //% advanced=false" line632="    export function digit_point(point: boolean) {" line633="        digit_pointFlag = point;" line634="" line635="        digit_bit(digit_buf[0], 0x00);" line636="        digit_bit(digit_buf[1], 0x01);" line637="        digit_bit(digit_buf[2], 0x02);" line638="        digit_bit(digit_buf[3], 0x03);" line639="    }" line640="" line641="    /**" line642="     * Clear the display" line643="     */" line644="    //% blockId=grove_tm1637_display_clear block=&quot;%strip|clear&quot;" line645="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line646="    //% advanced=false" line647="    export function digit_clear() {" line648="        digit_bit(0x7f, 0x00);" line649="        digit_bit(0x7f, 0x01);" line650="        digit_bit(0x7f, 0x02);" line651="        digit_bit(0x7f, 0x03);" line652="    }" line653="" line654="    /**" line655="     * WiFi/IoT" line656="     * Initialize ESP8266 module and connect it to Wifi router" line657="     */" line658="    //% block=&quot;Initialize ESP8266|RX (Tx of micro:bit) %tx|TX (Rx of micro:bit) %rx|Baud rate %baudrate|Wifi SSID = %ssid|Wifi PW = %pw&quot;" line659="    //% tx.defl=SerialPin.P0" line660="    //% rx.defl=SerialPin.P1" line661="    //% ssid.defl=your_ssid" line662="    //% pw.defl=your_pw" line663="    //% subcategory=IoT group=&quot;ThingSpeak&quot; color=#00F5A9 icon=&quot;\uf1eb&quot;    " line664="    //% advanced=false" line665="" line666="    export function connectWifi(tx: SerialPin, rx: SerialPin, baudrate: BaudRate, ssid: string, pw: string) {" line667="        wifi_connected = false" line668="        thingspeak_connected = false" line669="        serial.redirect(" line670="            tx," line671="            rx," line672="            baudrate" line673="        )" line674="        sendAT(&quot;AT+RESTORE&quot;, 1000) // restore to factory settings" line675="        sendAT(&quot;AT+CWMODE=1&quot;) // set to STA mode" line676="        sendAT(&quot;AT+RST&quot;, 1000) // reset" line677="        sendAT(&quot;AT+CWJAP=\&quot;&quot; + ssid + &quot;\&quot;,\&quot;&quot; + pw + &quot;\&quot;&quot;, 0) // connect to Wifi router" line678="        wifi_connected = waitResponse()" line679="        basic.pause(100)" line680="    }" line681="" line682="    /**" line683="    * Connect to ThingSpeak and upload data. It would not upload anything if it failed to connect to Wifi or ThingSpeak." line684="    */" line685="    //% block=&quot;Upload data to ThingSpeak|URL/IP = %ip|Write API key = %write_api_key|Field 1 = %n1|Field 2 = %n2|Field 3 = %n3|Field 4 = %n4|Field 5 = %n5|Field 6 = %n6|Field 7 = %n7|Field 8 = %n8&quot;" line686="    //% ip.defl=api.thingspeak.com" line687="    //% write_api_key.defl=your_write_api_key" line688="    //% subcategory=IoT group=&quot;ThingSpeak&quot; color=#00F5A9 icon=&quot;\uf1eb&quot;    " line689="    //% advanced=false" line690="" line691="    export function connectThingSpeak(ip: string, write_api_key: string, n1: number, n2: number, n3: number, n4: number, n5: number, n6: number, n7: number, n8: number) {" line692="        if (wifi_connected &amp;&amp; write_api_key != &quot;&quot;) {" line693="            thingspeak_connected = false" line694="            sendAT(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;&quot; + ip + &quot;\&quot;,80&quot;, 0) // connect to website server" line695="            thingspeak_connected = waitResponse()" line696="            basic.pause(100)" line697="            if (thingspeak_connected) {" line698="                last_upload_successful = false" line699="                let str: string = &quot;GET /update?api_key=&quot; + write_api_key + &quot;&amp;field1=&quot; + n1 + &quot;&amp;field2=&quot; + n2 + &quot;&amp;field3=&quot; + n3 + &quot;&amp;field4=&quot; + n4 + &quot;&amp;field5=&quot; + n5 + &quot;&amp;field6=&quot; + n6 + &quot;&amp;field7=&quot; + n7 + &quot;&amp;field8=&quot; + n8" line700="                sendAT(&quot;AT+CIPSEND=&quot; + (str.length + 2))" line701="                sendAT(str, 0) // upload data" line702="                last_upload_successful = waitResponse()" line703="                basic.pause(100)" line704="            }" line705="        }" line706="    }" line707="" line708="    /**" line709="    * Wait between uploads" line710="    */" line711="    //% block=&quot;Wait %delay ms&quot;" line712="    //% delay.min=0 delay.defl=5000" line713="    //% subcategory=IoT group=&quot;ThingSpeak&quot; color=#00F5A9 icon=&quot;\uf1eb&quot;    " line714="    //% advanced=false" line715="" line716="    export function wait(delay: number) {" line717="        if (delay &gt; 0) basic.pause(delay)" line718="    }" line719="" line720="    /**" line721="    * Check if ESP8266 successfully connected to Wifi" line722="    */" line723="    //% block=&quot;Wifi connected ?&quot;" line724="    //% subcategory=IoT group=&quot;ThingSpeak&quot; color=#00F5A9 icon=&quot;\uf1eb&quot;    " line725="    //% advanced=false" line726="" line727="    export function isWifiConnected() {" line728="        return wifi_connected" line729="    }" line730="" line731="    /**" line732="    * Check if ESP8266 successfully connected to ThingSpeak" line733="    */" line734="    //% block=&quot;ThingSpeak connected ?&quot;" line735="    //% subcategory=IoT group=&quot;ThingSpeak&quot; color=#00F5A9 icon=&quot;\uf1eb&quot;    " line736="    //% advanced=false" line737="" line738="    export function isThingSpeakConnected() {" line739="        return thingspeak_connected" line740="    }" line741="" line742="    /**" line743="    * Check if ESP8266 successfully uploaded data to ThingSpeak" line744="    */" line745="    //% block=&quot;Last data upload successful ?&quot;" line746="    //% subcategory=IoT group=&quot;ThingSpeak&quot; color=#00F5A9 icon=&quot;\uf1eb&quot;    " line747="    //% advanced=false" line748="" line749="    export function isLastUploadSuccessful() {" line750="        return last_upload_successful" line751="    }" line752="" line753="    /*" line754="     * Private functions" line755="     */" line756="    function swap16(val: NumberFormat.UInt16BE) {" line757="        return ((val &amp; 0xFF) &lt;&lt; 8)" line758="            | ((val &gt;&gt; 8) &amp; 0xFF);" line759="    }" line760="" line761="    function setDir(motor: Motors, dir: MotorDirection): void {" line762="        switch (motor) {" line763="            case Motors.Motor1: //gauche" line764="                _dir_left = dir;" line765="                break" line766="            case Motors.Motor2: //droit" line767="                _dir_right = dir;" line768="                break" line769="            case Motors.MotorFull: //droit" line770="                _dir_left = dir;" line771="                _dir_right = dir;" line772="                break" line773="        }" line774="    }" line775="" line776="    function setSpeed(motor: Motors, speed: number): void {" line777="        let corrected_speed = Math.min(Math.map(speed, 0, 100, 0, 1023), 1023);" line778="        switch (motor) {" line779="            case Motors.Motor1:" line780="                _speed_left = corrected_speed;" line781="                break" line782="            case Motors.Motor2:" line783="                _speed_right = corrected_speed;" line784="                break" line785="            case Motors.MotorFull:" line786="                _speed_left = corrected_speed;" line787="                _speed_right = corrected_speed;" line788="                break" line789="        }" line790="    }" line791="" line792="    function setMotors(): void {" line793="        if (_dir_right == 1) {" line794="            pins.digitalWritePin(DigitalPin.P15, 0);" line795="            pins.analogWritePin(AnalogPin.P16, _speed_right);" line796="        } else if (_dir_right == 2) {" line797="            pins.analogWritePin(AnalogPin.P15, _speed_right);" line798="            pins.digitalWritePin(DigitalPin.P16, 0);" line799="        } else {" line800="            pins.digitalWritePin(DigitalPin.P15, 0);" line801="            pins.digitalWritePin(DigitalPin.P16, 0);" line802="        }" line803="        if (_dir_left == 1) {" line804="            pins.digitalWritePin(DigitalPin.P13, 0);" line805="            pins.analogWritePin(AnalogPin.P14, _speed_left);" line806="        } else if (_dir_left == 2) {" line807="            pins.analogWritePin(AnalogPin.P13, _speed_left);" line808="            pins.digitalWritePin(DigitalPin.P14, 0);" line809="        } else {" line810="            pins.digitalWritePin(DigitalPin.P13, 0);" line811="            pins.digitalWritePin(DigitalPin.P14, 0);" line812="        }" line813="    }" line814="" line815="    function digit_writeByte(wrData: number) {" line816="        for (let i = 0; i &lt; 8; i++) {" line817="            pins.digitalWritePin(digit_clkPin, 0);" line818="            if (wrData &amp; 0x01) pins.digitalWritePin(digit_dataPin, 1);" line819="            else pins.digitalWritePin(digit_dataPin, 0);" line820="            wrData &gt;&gt;= 1;" line821="            pins.digitalWritePin(digit_clkPin, 1);" line822="        }" line823="" line824="        pins.digitalWritePin(digit_clkPin, 0); // Wait for ACK" line825="        pins.digitalWritePin(digit_dataPin, 1);" line826="        pins.digitalWritePin(digit_clkPin, 1);" line827="    }" line828="" line829="    function digit_start() {" line830="        pins.digitalWritePin(digit_clkPin, 1);" line831="        pins.digitalWritePin(digit_dataPin, 1);" line832="        pins.digitalWritePin(digit_dataPin, 0);" line833="        pins.digitalWritePin(digit_clkPin, 0);" line834="    }" line835="" line836="    function digit_stop() {" line837="        pins.digitalWritePin(digit_clkPin, 0);" line838="        pins.digitalWritePin(digit_dataPin, 0);" line839="        pins.digitalWritePin(digit_clkPin, 1);" line840="        pins.digitalWritePin(digit_dataPin, 1);" line841="    }" line842="" line843="    function digit_coding(dispData: number): number {" line844="        let pointData = 0;" line845="" line846="        if (digit_pointFlag == true) pointData = 0x80;" line847="        else if (digit_pointFlag == false) pointData = 0;" line848="" line849="        if (dispData == 0x7f) dispData = 0x00 + pointData;" line850="        else dispData = TubeTab[dispData] + pointData;" line851="" line852="        return dispData;" line853="    }" line854="" line855="    function paj7620WriteReg(addr: number, cmd: number) {" line856="        let buf: Buffer = pins.createBuffer(2);" line857="" line858="        buf[0] = addr;" line859="        buf[1] = cmd;" line860="" line861="        pins.i2cWriteBuffer(0x73, buf, false);" line862="    }" line863="" line864="    function paj7620ReadReg(addr: number): number {" line865="        let buf2: Buffer = pins.createBuffer(1);" line866="" line867="        buf2[0] = addr;" line868="" line869="        pins.i2cWriteBuffer(0x73, buf2, false);" line870="" line871="        buf2 = pins.i2cReadBuffer(0x73, 1, false);" line872="" line873="        return buf2[0];" line874="    }" line875="" line876="    function paj7620SelectBank(bank: number) {" line877="        if (bank == 0) paj7620WriteReg(0xEF, 0);" line878="        else if (bank == 1) paj7620WriteReg(0xEF, 1);" line879="    }" line880="" line881="    function paj7620Init() {" line882="        let temp = 0;" line883="" line884="        paj7620SelectBank(0);" line885="" line886="        temp = paj7620ReadReg(0);" line887="        if (temp == 0x20) {" line888="            for (let j = 0; j &lt; 438; j += 2) {" line889="                paj7620WriteReg(initRegisterArray[j], initRegisterArray[j + 1]);" line890="            }" line891="        }" line892="" line893="        paj7620SelectBank(0);" line894="    }" line895="" line896="    /**" line897="     * Iot ThingSpeak" line898="    **/" line899="" line900="    // write AT command with CR+LF ending" line901="    function sendAT(command: string, wait: number = 100) {" line902="        serial.writeString(command + &quot;\u000D\u000A&quot;)" line903="        basic.pause(wait)" line904="    }" line905="" line906="    // wait for certain response from ESP8266" line907="    function waitResponse(): boolean {" line908="        let serial_str: string = &quot;&quot;" line909="        let result2: boolean = false" line910="        let time: number = input.runningTime()" line911="        while (true) {" line912="            serial_str += serial.readString()" line913="            if (serial_str.length &gt; 200) serial_str = serial_str.substr(serial_str.length - 200)" line914="            if (serial_str.includes(&quot;OK&quot;) || serial_str.includes(&quot;ALREADY CONNECTED&quot;)) {" line915="                result2 = true" line916="                break" line917="            } else if (serial_str.includes(&quot;ERROR&quot;) || serial_str.includes(&quot;SEND FAIL&quot;)) {" line918="                break" line919="            }" line920="            if (input.runningTime() - time &gt; 30000) break" line921="        }" line922="        return result2" line923="    }" line924="    /**" line925="     * end Iot ThingSpeak" line926="    **/" line927="" line928="" line929="}" numlines="930"></mutation></block></statement></block></xml>