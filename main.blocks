<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="_I|~Ef*zW2su#b?t4-,3" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="e@i/t}Okv70_5%Ab[h^j" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace hackbit {" line1="    let gesture_first_init = true" line2="    const initRegisterArray: number[] = [" line3="        0xEF, 0x00, 0x32, 0x29, 0x33, 0x01, 0x34, 0x00, 0x35, 0x01, 0x36, 0x00, 0x37, 0x07, 0x38, 0x17," line4="        0x39, 0x06, 0x3A, 0x12, 0x3F, 0x00, 0x40, 0x02, 0x41, 0xFF, 0x42, 0x01, 0x46, 0x2D, 0x47, 0x0F," line5="        0x48, 0x3C, 0x49, 0x00, 0x4A, 0x1E, 0x4B, 0x00, 0x4C, 0x20, 0x4D, 0x00, 0x4E, 0x1A, 0x4F, 0x14," line6="        0x50, 0x00, 0x51, 0x10, 0x52, 0x00, 0x5C, 0x02, 0x5D, 0x00, 0x5E, 0x10, 0x5F, 0x3F, 0x60, 0x27," line7="        0x61, 0x28, 0x62, 0x00, 0x63, 0x03, 0x64, 0xF7, 0x65, 0x03, 0x66, 0xD9, 0x67, 0x03, 0x68, 0x01," line8="        0x69, 0xC8, 0x6A, 0x40, 0x6D, 0x04, 0x6E, 0x00, 0x6F, 0x00, 0x70, 0x80, 0x71, 0x00, 0x72, 0x00," line9="        0x73, 0x00, 0x74, 0xF0, 0x75, 0x00, 0x80, 0x42, 0x81, 0x44, 0x82, 0x04, 0x83, 0x20, 0x84, 0x20," line10="        0x85, 0x00, 0x86, 0x10, 0x87, 0x00, 0x88, 0x05, 0x89, 0x18, 0x8A, 0x10, 0x8B, 0x01, 0x8C, 0x37," line11="        0x8D, 0x00, 0x8E, 0xF0, 0x8F, 0x81, 0x90, 0x06, 0x91, 0x06, 0x92, 0x1E, 0x93, 0x0D, 0x94, 0x0A," line12="        0x95, 0x0A, 0x96, 0x0C, 0x97, 0x05, 0x98, 0x0A, 0x99, 0x41, 0x9A, 0x14, 0x9B, 0x0A, 0x9C, 0x3F," line13="        0x9D, 0x33, 0x9E, 0xAE, 0x9F, 0xF9, 0xA0, 0x48, 0xA1, 0x13, 0xA2, 0x10, 0xA3, 0x08, 0xA4, 0x30," line14="        0xA5, 0x19, 0xA6, 0x10, 0xA7, 0x08, 0xA8, 0x24, 0xA9, 0x04, 0xAA, 0x1E, 0xAB, 0x1E, 0xCC, 0x19," line15="        0xCD, 0x0B, 0xCE, 0x13, 0xCF, 0x64, 0xD0, 0x21, 0xD1, 0x0F, 0xD2, 0x88, 0xE0, 0x01, 0xE1, 0x04," line16="        0xE2, 0x41, 0xE3, 0xD6, 0xE4, 0x00, 0xE5, 0x0C, 0xE6, 0x0A, 0xE7, 0x00, 0xE8, 0x00, 0xE9, 0x00," line17="        0xEE, 0x07, 0xEF, 0x01, 0x00, 0x1E, 0x01, 0x1E, 0x02, 0x0F, 0x03, 0x10, 0x04, 0x02, 0x05, 0x00," line18="        0x06, 0xB0, 0x07, 0x04, 0x08, 0x0D, 0x09, 0x0E, 0x0A, 0x9C, 0x0B, 0x04, 0x0C, 0x05, 0x0D, 0x0F," line19="        0x0E, 0x02, 0x0F, 0x12, 0x10, 0x02, 0x11, 0x02, 0x12, 0x00, 0x13, 0x01, 0x14, 0x05, 0x15, 0x07," line20="        0x16, 0x05, 0x17, 0x07, 0x18, 0x01, 0x19, 0x04, 0x1A, 0x05, 0x1B, 0x0C, 0x1C, 0x2A, 0x1D, 0x01," line21="        0x1E, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x25, 0x01, 0x26, 0x00, 0x27, 0x39, 0x28, 0x7F," line22="        0x29, 0x08, 0x30, 0x03, 0x31, 0x00, 0x32, 0x1A, 0x33, 0x1A, 0x34, 0x07, 0x35, 0x07, 0x36, 0x01," line23="        0x37, 0xFF, 0x38, 0x36, 0x39, 0x07, 0x3A, 0x00, 0x3E, 0xFF, 0x3F, 0x00, 0x40, 0x77, 0x41, 0x40," line24="        0x42, 0x00, 0x43, 0x30, 0x44, 0xA0, 0x45, 0x5C, 0x46, 0x00, 0x47, 0x00, 0x48, 0x58, 0x4A, 0x1E," line25="        0x4B, 0x1E, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0xA0, 0x4F, 0x80, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00," line26="        0x53, 0x00, 0x54, 0x00, 0x57, 0x80, 0x59, 0x10, 0x5A, 0x08, 0x5B, 0x94, 0x5C, 0xE8, 0x5D, 0x08," line27="        0x5E, 0x3D, 0x5F, 0x99, 0x60, 0x45, 0x61, 0x40, 0x63, 0x2D, 0x64, 0x02, 0x65, 0x96, 0x66, 0x00," line28="        0x67, 0x97, 0x68, 0x01, 0x69, 0xCD, 0x6A, 0x01, 0x6B, 0xB0, 0x6C, 0x04, 0x6D, 0x2C, 0x6E, 0x01," line29="        0x6F, 0x32, 0x71, 0x00, 0x72, 0x01, 0x73, 0x35, 0x74, 0x00, 0x75, 0x33, 0x76, 0x31, 0x77, 0x01," line30="        0x7C, 0x84, 0x7D, 0x03, 0x7E, 0x01" line31="    ];" line32="    /////////////////////////color/////////////////////////" line33="    const APDS9960_ADDR = 0x39" line34="    const APDS9960_ENABLE = 0x80" line35="    const APDS9960_ATIME = 0x81" line36="    const APDS9960_CONTROL = 0x8F" line37="    const APDS9960_STATUS = 0x93" line38="    const APDS9960_CDATAL = 0x94" line39="    const APDS9960_CDATAH = 0x95" line40="    const APDS9960_RDATAL = 0x96" line41="    const APDS9960_RDATAH = 0x97" line42="    const APDS9960_GDATAL = 0x98" line43="    const APDS9960_GDATAH = 0x99" line44="    const APDS9960_BDATAL = 0x9A" line45="    const APDS9960_BDATAH = 0x9B" line46="    const APDS9960_GCONF4 = 0xAB" line47="    const APDS9960_AICLEAR = 0xE7    " line48="    let color_first_init = false" line49="" line50="    export enum OnOff {" line51="        //% block=&quot;On&quot;" line52="        On = 1," line53="        //% block=&quot;Off&quot;" line54="        Off = 0" line55="    }" line56="" line57="    export enum Color {" line58="        //% block=&quot;Red&quot;" line59="        Red," line60="        //% block=&quot;Green&quot;" line61="        Green," line62="        //% block=&quot;Blue&quot;" line63="        Blue," line64="        //% block=&quot;Clear&quot;" line65="        Clear" line66="    }" line67="" line68="    export enum ColorList {" line69="        //% block=&quot;Red&quot;" line70="        red," line71="        //% block=&quot;Green&quot;" line72="        green," line73="        //% block=&quot;Blue&quot;" line74="        blue," line75="        //% block=&quot;Cyan&quot;" line76="        cyan," line77="        //% block=&quot;Magenta&quot;" line78="        magenta," line79="        //% block=&quot;Yellow&quot;" line80="        yellow," line81="        //% block=&quot;White&quot;" line82="        white" line83="    }" line84="" line85="    export enum GroveGesture {" line86="        //% block=None" line87="        None = 0," line88="        //% block=Right" line89="        Right = 1," line90="        //% block=Left" line91="        Left = 2," line92="        //% block=Up" line93="        Up = 3," line94="        //% block=Down" line95="        Down = 4," line96="        //% block=Forward" line97="        Forward = 5," line98="        //% block=Backward" line99="        Backward = 6," line100="        //% block=Clockwise" line101="        Clockwise = 7," line102="        //% block=Anticlockwise" line103="        Anticlockwise = 8," line104="        //% block=Wave" line105="        Wave = 9" line106="    }" line107="" line108="    export enum DHT11_state {" line109="        //% block=&quot;temperature(℃)&quot; enumval=0" line110="        DHT11_temperature_C," line111="" line112="        //% block=&quot;humidity(0~100)&quot; enumval=1" line113="        DHT11_humidity," line114="    }" line115="" line116="    export enum GasList {" line117="        //% block=&quot;Co&quot;" line118="        Co," line119="        //% block=&quot;Co2&quot;" line120="        Co2," line121="        //% block=&quot;Smoke&quot;" line122="        Smoke," line123="        //% block=&quot;Alcohol&quot;" line124="        Alcohol" line125="    }" line126="    " line127="&#9;export enum GroveJoystickKey {" line128="&#9;&#9;//% block=&quot;none&quot;" line129="&#9;&#9;None = 0," line130="&#9;&#9;//%block=&quot;Right&quot;" line131="&#9;&#9;Right = 1," line132="&#9;&#9;//% block=&quot;Left&quot;" line133="&#9;&#9;Left = 2," line134="&#9;&#9;//% block=&quot;Up&quot;" line135="&#9;&#9;Up = 3," line136="&#9;&#9;//% block=&quot;Down&quot;" line137="&#9;&#9;Down = 4," line138="&#9;&#9;//% block=&quot;Upper left&quot;" line139="&#9;&#9;UL = 5," line140="&#9;&#9;//% block=&quot;Upper right&quot;" line141="&#9;&#9;UR = 6," line142="&#9;&#9;//% block=&quot;Lower left&quot;" line143="&#9;&#9;LL = 7," line144="&#9;&#9;//% block=&quot;Lower right&quot;" line145="&#9;&#9;LR = 8," line146="&#9;&#9;//% block=&quot;press&quot;" line147="&#9;&#9;Press = 9" line148="&#9;}" line149="" line150="    export let identifiant = 0;" line151="    export let grovegestureinit = 0;" line152="" line153="    let TubeTab: number[] = [" line154="        0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07," line155="        0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71" line156="    ];" line157="" line158="    export let digit_clkPin: DigitalPin;" line159="    export let digit_dataPin: DigitalPin;" line160="    export let digit_brightnessLevel: number;" line161="    export let digit_pointFlag: boolean;" line162="    export let digit_buf: Buffer;" line163="" line164="    /**" line165="     * Set relay state" line166="    */" line167="    //% blockId=hackbitRelay" line168="    //% block=&quot;relay pin |%pin| state |%RelayState|&quot;" line169="    //% pin.fieldEditor=&quot;gridpicker&quot;" line170="    //% pin.fieldOptions.columns=2" line171="    //% RelayState.fieldEditor=&quot;gridpicker&quot;" line172="    //% RelayState.fieldOptions.columns=1" line173="    //% RelayState.min=0 state.max=1" line174="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line175="    export function hackbitRelayState(pin: DigitalPin, RelayState: OnOff): void {" line176="        switch (RelayState) {" line177="            case 0:" line178="                pins.digitalWritePin(pin, 0)" line179="                break;" line180="            case 1:" line181="                pins.digitalWritePin(pin, 1)" line182="                break;" line183="        }" line184="    }" line185="" line186="    /**" line187="     * Set vibration motor state" line188="    */" line189="    //% blockId=hackbitVibrationMotor" line190="    //% block=&quot;vibration motor pin |%pin| state |%VibrationMotorState|&quot;" line191="    //% pin.fieldEditor=&quot;gridpicker&quot;" line192="    //% pin.fieldOptions.columns=2" line193="    //% VibrationMotor.fieldEditor=&quot;gridpicker&quot;" line194="    //% VibrationMotor.fieldOptions.columns=1" line195="    //% VibrationMotor.min=0 state.max=1" line196="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line197="    export function hackbitVibrationMotorState(pin: DigitalPin, VibrationMotorState: OnOff): void {" line198="        switch (VibrationMotorState) {" line199="            case 0:" line200="                pins.digitalWritePin(pin, 0)" line201="                break;" line202="            case 1:" line203="                pins.digitalWritePin(pin, 1)" line204="                break;" line205="        }" line206="    }" line207="" line208="    /**" line209="     * Set mini fan state" line210="    */" line211="    //% blockId=hackbitMiniFan" line212="    //% block=&quot;mini fan pin |%pin| state |%MiniFanState|&quot;" line213="    //% pin.fieldEditor=&quot;gridpicker&quot;" line214="    //% pin.fieldOptions.columns=2" line215="    //% MiniFanState.fieldEditor=&quot;gridpicker&quot;" line216="    //% MiniFanState.fieldOptions.columns=1" line217="    //% MiniFanState.min=0 state.max=1" line218="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line219="    export function hackbitMiniFanState(pin: DigitalPin, MiniFanState: OnOff): void {" line220="        switch (MiniFanState) {" line221="            case 0:" line222="                pins.digitalWritePin(pin, 0)" line223="                break;" line224="            case 1:" line225="                pins.digitalWritePin(pin, 1)" line226="                break;" line227="        }" line228="    }" line229="" line230="    /**" line231="     * Set laser state" line232="    */" line233="    //% blockId=hackbitLaser" line234="    //% block=&quot;laser pin |%pin| state |%LaserState|&quot;" line235="    //% pin.fieldEditor=&quot;gridpicker&quot;" line236="    //% pin.fieldOptions.columns=2" line237="    //% LaserState.fieldEditor=&quot;gridpicker&quot;" line238="    //% LaserState.fieldOptions.columns=1" line239="    //% LaserState.min=0 state.max=1" line240="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line241="    export function hackbitLaserState(pin: DigitalPin, LaserState: OnOff): void {" line242="        switch (LaserState) {" line243="            case 0:" line244="                pins.digitalWritePin(pin, 0)" line245="                break;" line246="            case 1:" line247="                pins.digitalWritePin(pin, 1)" line248="                break;" line249="        }" line250="    }" line251="" line252="" line253="    /**" line254="     * get distance from ultrasonic range sensor [cm]" line255="     * @param pin Input pin" line256="     */" line257="    //% blockId=RobotDriverultrasonic_cm " line258="    //% block=&quot;ultrasonic ranger pin |%name| distance(cm)&quot;" line259="    //% name.fieldEditor=&quot;gridpicker&quot; " line260="    //% name.fieldOptions.columns=5" line261="    //% name.fieldOptions.tooltips=&quot;false&quot;" line262="    //% name.fieldOptions.width=&quot;0&quot;" line263="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;" line264="    export function measureDistanceCentimeter(name: DigitalPin): number {" line265="        let duration = 0;" line266="        let distance = 0;" line267="        pins.digitalWritePin(name, 0); //make sure pin is low" line268="        control.waitMicros(2);" line269="        pins.digitalWritePin(name, 1); //send echo" line270="        control.waitMicros(20);" line271="        pins.digitalWritePin(name, 0);" line272="        duration = pins.pulseIn(name, PulseValue.High, 50000); // Max duration 50 ms - receive echo" line273="        distance = duration * 153 / 29 / 2 / 100;" line274="        Math.constrain(distance, 0, 500);" line275="        return distance;" line276="    }" line277="" line278="    /**" line279="     * Get line finder sensor state [0-1]" line280="    */" line281="    //% blockId=hackbitLineFinderRead" line282="    //% block=&quot;pin |%pin| line finder is seeing black&quot;" line283="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line284="    export function detectline(pin: DigitalPin): boolean {" line285="        pins.setPull(pin, PinPullMode.PullUp)" line286="        if (pins.digitalReadPin(pin) == 0) {" line287="            return true" line288="        }" line289="        else {" line290="            return false" line291="        }" line292="    }" line293="" line294="    /**" line295="     * Get collision sensor state [0-1]" line296="    */" line297="    //% blockId=hackbitCollisionRead" line298="    //% block=&quot;collision sensor pin |%pin| activated&quot;" line299="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line300="    export function collisionSensor(pin: DigitalPin): boolean {" line301="        pins.setPull(pin, PinPullMode.PullUp)" line302="        if (pins.digitalReadPin(pin) == 0) {" line303="            return true" line304="        }" line305="        else {" line306="            return false" line307="        }" line308="    }" line309="" line310="    /**" line311="     * Get PIR sensor state [0-1]" line312="    */" line313="    //% blockId=hackbitPIRRead" line314="    //% block=&quot;PIR sensor pin |%pin| detects motion&quot;" line315="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line316="    export function PIRState(pin: DigitalPin): boolean {" line317="        pins.setPull(pin, PinPullMode.PullUp)" line318="        if (pins.digitalReadPin(pin) == 0) {" line319="            return true" line320="        }" line321="        else {" line322="            return false" line323="        }" line324="    }" line325="" line326="    /**" line327="     * Get water sensor state [0-1]" line328="    */" line329="    //% blockId=hackbitWaterRead" line330="    //% block=&quot;water sensor pin |%pin| detects water&quot;" line331="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line332="    export function WaterState(pin: DigitalPin): boolean {" line333="        pins.setPull(pin, PinPullMode.PullUp)" line334="        if (pins.digitalReadPin(pin) == 0) {" line335="            return true" line336="        }" line337="        else {" line338="            return false" line339="        }" line340="    }" line341="" line342="    /**" line343="     * Get Magnetic Switch state [0-1]" line344="    */" line345="    //% blockId=hackbitMagneticSwitchRead" line346="    //% block=&quot;magnetic switch pin |%pin| activated&quot;" line347="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line348="    export function MagneticSwitchState(pin: DigitalPin): boolean {" line349="        pins.setPull(pin, PinPullMode.PullUp)" line350="        if (pins.digitalReadPin(pin) == 0) {" line351="            return true" line352="        }" line353="        else {" line354="            return false" line355="        }" line356="    }" line357="" line358="    /**" line359="     * Get hall sensor state [0-1]" line360="    */" line361="    //% blockId=hackbitHallRead" line362="    //% block=&quot;hall sensor pin |%pin| activated&quot;" line363="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line364="    export function HallState(pin: DigitalPin): boolean {" line365="        pins.setPull(pin, PinPullMode.PullUp)" line366="        if (pins.digitalReadPin(pin) == 0) {" line367="            return true" line368="        }" line369="        else {" line370="            return false" line371="        }" line372="    }" line373="" line374="    /**" line375="     * Get crash button state [0-1]" line376="    */" line377="    //% blockId=hackbitCrashRead" line378="    //% block=&quot;crash sensor |%pin| is pressed&quot;" line379="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;    " line380="    export function CrashButton(pin: DigitalPin): boolean {" line381="        pins.setPull(pin, PinPullMode.PullUp)" line382="        if (pins.digitalReadPin(pin) == 0) {" line383="            return true" line384="        }" line385="        else {" line386="            return false" line387="        }" line388="    }        " line389="" line390="    /**" line391="     * Get flame sensor state [0-1]" line392="    */" line393="    //% blockId=hackbitFlameRead" line394="    //% block=&quot;flame sensor pin |%pin| detects flame&quot;" line395="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line396="    export function FlameState(pin: DigitalPin): boolean {" line397="        pins.setPull(pin, PinPullMode.PullUp)" line398="        if (pins.digitalReadPin(pin) == 0) {" line399="            return true" line400="        }" line401="        else {" line402="            return false" line403="        }" line404="    }" line405="" line406="    /**" line407="     * Get touch sensor state [0-1]" line408="    */" line409="    //% blockId=hackbitTouchRead" line410="    //% block=&quot;touch sensor pin |%pin| touched&quot;" line411="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line412="    export function TouchState(pin: DigitalPin): boolean {" line413="        pins.setPull(pin, PinPullMode.PullUp)" line414="        if (pins.digitalReadPin(pin) == 0) {" line415="            return true" line416="        }" line417="        else {" line418="            return false" line419="        }" line420="    }" line421="" line422="    /**" line423="     * Get vibration state [0-1]" line424="    */" line425="    //% blockId=hackbitVibrationRead" line426="    //% block=&quot;vibration sensor pin |%pin| detects vibration&quot;" line427="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;    " line428="    export function VibrationRead(pin: DigitalPin): boolean {" line429="        pins.setPull(pin, PinPullMode.PullUp)" line430="        if (pins.digitalReadPin(pin) == 0) {" line431="            return true" line432="        }" line433="        else {" line434="            return false" line435="        }" line436="    }        " line437="" line438="    /**" line439="     * Get button state [0-1]" line440="    */" line441="    //% blockId=hackbitButtonRead" line442="    //% block=&quot;button pin |%pin| is pressed&quot;" line443="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line444="    export function buttonState(pin: DigitalPin): boolean {" line445="        pins.setPull(pin, PinPullMode.PullUp)" line446="        if (pins.digitalReadPin(pin) == 0) {" line447="            return true" line448="        }" line449="        else {" line450="            return false" line451="        }" line452="    }" line453="" line454="    /**" line455="     * Get button LED state [0-1]" line456="    */" line457="    //% blockId=hackbitButtonLEDRead" line458="    //% block=&quot;button pin LED |%pin| is pressed&quot;" line459="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line460="    export function buttonLEDState(pin: DigitalPin): boolean {" line461="        pins.setPull(pin, PinPullMode.PullUp)" line462="        if (pins.digitalReadPin(pin) == 0) {" line463="            return true" line464="        }" line465="        else {" line466="            return false" line467="        }" line468="    }" line469="" line470="    /**" line471="     * Get Tilt state [0-1]" line472="    */" line473="    //% blockId=hackbitTiltRead" line474="    //% block=&quot;tilt switch pin |%pin| tilted&quot;" line475="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line476="    export function TiltState(pin: DigitalPin): boolean {" line477="        pins.setPull(pin, PinPullMode.PullUp)" line478="        if (pins.digitalReadPin(pin) == 0) {" line479="            return true" line480="        }" line481="        else {" line482="            return false" line483="        }" line484="    }" line485="" line486="    /**" line487="     * Get Switch (P) state [0-1]" line488="    */" line489="    //% blockId=hackbitSwitchRead" line490="    //% block=&quot;switch(P) pin |%pin| activated&quot;" line491="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line492="    export function SwitchState(pin: DigitalPin): boolean {" line493="        pins.setPull(pin, PinPullMode.PullUp)" line494="        if (pins.digitalReadPin(pin) == 0) {" line495="            return true" line496="        }" line497="        else {" line498="            return false" line499="        }" line500="    }" line501="" line502="    /**" line503="    * Get soil moisture(0~100%)" line504="    * @param soilmoisturepin describe parameter here, eg: AnalogPin.P1" line505="    */" line506="    //% blockId=&quot;hackbitSoilMoistureRead&quot; block=&quot;value of soil moisture(0~100) at pin %soilhumiditypin&quot;" line507="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line508="    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {" line509="        let voltage = 0;" line510="        let soilmoisture = 0;" line511="        voltage = pins.map(" line512="            pins.analogReadPin(soilmoisturepin)," line513="            0," line514="            1023," line515="            0," line516="            100" line517="        );" line518="        soilmoisture = voltage;" line519="        return Math.round(soilmoisture);" line520="    }" line521="" line522="    /**" line523="    * Get light intensity(0~100%)" line524="    * @param lightintensitypin describe parameter here, eg: AnalogPin.P1" line525="    */" line526="    //% blockId=&quot;hackbitLightIntensityRead&quot; block=&quot;value of light intensity(0~100) at pin %lightintensitypin&quot;" line527="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line528="    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {" line529="        let voltage2 = 0;" line530="        let lightintensity = 0;" line531="        voltage2 = pins.map(" line532="            pins.analogReadPin(lightintensitypin)," line533="            0," line534="            1023," line535="            0," line536="            100" line537="        );" line538="        lightintensity = voltage2;" line539="        return Math.round(lightintensity);" line540="    }" line541="" line542="    /**" line543="    * Get UV level value (0~15)" line544="    * @param uvlevelpin describe parameter here, eg: AnalogPin.P1" line545="    */" line546="    //% blockId=&quot;hackbitUVLevelRead&quot; block=&quot;UV sensor (0~15) at pin %uvlevelpin&quot;" line547="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line548="    export function UVLevel(uvlevelpin: AnalogPin): number {" line549="        let UVlevel = pins.analogReadPin(uvlevelpin);" line550="        if (UVlevel &gt; 625) {" line551="            UVlevel = 625" line552="        }" line553="        UVlevel = pins.map(" line554="            UVlevel," line555="            0," line556="            625," line557="            0," line558="            15" line559="        );" line560="        return Math.round(UVlevel)" line561="    }" line562="" line563="    /**" line564="    * Get dht11 temperature and humidity Value" line565="    * @param dht11pin describe parameter here, eg: DigitalPin.P15     " line566="    */" line567="    //% blockId=&quot;hackbitDHT11Read&quot; block=&quot;DHT11 sensor %DHT11pin %dht11state value&quot;" line568="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line569="    export function dht11Sensor(DHT11pin: DigitalPin, dht11state: DHT11_state): number {" line570="        basic.pause(1000)  //There must be more than 2000ms between two requests" line571="        pins.digitalWritePin(DHT11pin, 0)" line572="        basic.pause(18)" line573="        let i = pins.digitalReadPin(DHT11pin)" line574="        pins.setPull(DHT11pin, PinPullMode.PullUp);" line575="        switch (dht11state) {" line576="            case 0:" line577="                let dhtvalue1 = 0;" line578="                let dhtcounter1 = 0;" line579="                while (pins.digitalReadPin(DHT11pin) == 1);" line580="                while (pins.digitalReadPin(DHT11pin) == 0);" line581="                while (pins.digitalReadPin(DHT11pin) == 1);" line582="                for (let j = 0; j &lt;= 32 - 1; j++) {" line583="                    while (pins.digitalReadPin(DHT11pin) == 0);" line584="                    dhtcounter1 = 0" line585="                    while (pins.digitalReadPin(DHT11pin) == 1) {" line586="                        dhtcounter1 += 1;" line587="                    }" line588="                    if (j &gt; 15) {" line589="                        if (dhtcounter1 &gt; 2) {" line590="                            dhtvalue1 = dhtvalue1 + (1 &lt;&lt; (31 - j));" line591="                        }" line592="                    }" line593="                }" line594="                return ((dhtvalue1 &amp; 0x0000ff00) &gt;&gt; 8);" line595="                break;" line596="            case 1:" line597="                while (pins.digitalReadPin(DHT11pin) == 1);" line598="                while (pins.digitalReadPin(DHT11pin) == 0);" line599="                while (pins.digitalReadPin(DHT11pin) == 1);" line600="" line601="                let value = 0;" line602="                let counter = 0;" line603="" line604="                for (let k = 0; k &lt;= 8 - 1; k++) {" line605="                    while (pins.digitalReadPin(DHT11pin) == 0);" line606="                    counter = 0" line607="                    while (pins.digitalReadPin(DHT11pin) == 1) {" line608="                        counter += 1;" line609="                    }" line610="                    if (counter &gt; 3) {" line611="                        value = value + (1 &lt;&lt; (7 - k));" line612="                    }" line613="                }" line614="                return value;" line615="            default:" line616="                return 0;" line617="        }" line618="    }" line619="" line620="    /** " line621="    * Get temperature value Celsius" line622="    * @param temperaturepin describe parameter here, eg: AnalogPin.P1" line623="    */" line624="    //% blockId=&quot;hackbitTemperatureRead&quot; block=&quot;value of temperature (Celsius) at pin %temperaturepin&quot;" line625="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line626="    export function ReadTemperature(temperaturepin: AnalogPin): number {" line627="        let A               // value " line628="        let B = 4275        // B value of the thermistor" line629="        let R = 0" line630="        let R0 = 100000     // R0 = 100k" line631="        let temp = 0" line632="        A = pins.analogReadPin(temperaturepin)" line633="        R = 1023.0/A-1.0" line634="        R = R0*R;" line635="        temp = 1.0/(Math.log(R/R0)/B+1/298.15)-273.15 // convert to temperature via datasheet" line636="        return Math.round(temp)" line637="    }" line638="" line639="    /** " line640="    * Get Gas Sensor concentration value " line641="    */" line642="    //% blockId=&quot;hackbitGasRead&quot; block=&quot;%sensor gas sensor at pin %gaspin concentration value&quot;" line643="    //% gaspin.fieldEditor=&quot;gridpicker&quot; gaspin.fieldOptions.columns=2" line644="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=2    " line645="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line646="    export function hackbitGasRead(sensor: GasList, gaspin: AnalogPin): number {" line647="        if(sensor==GasList.Co2){" line648="            return 1024-pins.analogReadPin(gaspin)" line649="        }" line650="        return pins.analogReadPin(gaspin)" line651="    }" line652="" line653="    /** " line654="    * Get noise(dB)" line655="    * @param noisepin describe parameter here, eg: AnalogPin.P1, (Loudness Sensor)" line656="    */" line657="    //% blockId=&quot;hackbitNoiseRead&quot; block=&quot;value of noise(dB) at pin %noisepin&quot;" line658="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line659="    export function ReadNoise(noisepin: AnalogPin): number {" line660="        let level = 0" line661="        let voltage3 = 0" line662="        let noise = 0" line663="        let h = 0" line664="        let l = 0" line665="        let sumh = 0" line666="        let suml = 0" line667="        pins.digitalWritePin(DigitalPin.P0, 0)" line668="        for (let m = 0; m &lt; 1000; m++) {" line669="            level = level + pins.analogReadPin(noisepin)" line670="        }" line671="        level = level / 1000" line672="        for (let n = 0; n &lt; 1000; n++) {" line673="            voltage3 = pins.analogReadPin(noisepin)" line674="            if (voltage3 &gt;= level) {" line675="                h += 1" line676="                sumh = sumh + voltage3" line677="            } else {" line678="                l += 1" line679="                suml = suml + voltage3" line680="            }" line681="        }" line682="        if (h == 0) {" line683="            sumh = level" line684="        } else {" line685="            sumh = sumh / h" line686="        }" line687="        if (l == 0) {" line688="            suml = level" line689="        } else {" line690="            suml = suml / l" line691="        }" line692="        noise = sumh - suml" line693="        if (noise &lt;= 4) {" line694="            noise = pins.map(" line695="                noise," line696="                0," line697="                4," line698="                30," line699="                50" line700="            )" line701="        } else if (noise &lt;= 8) {" line702="            noise = pins.map(" line703="                noise," line704="                4," line705="                8," line706="                50," line707="                55" line708="            )" line709="        } else if (noise &lt;= 14) {" line710="            noise = pins.map(" line711="                noise," line712="                9," line713="                14," line714="                55," line715="                60" line716="            )" line717="        } else if (noise &lt;= 32) {" line718="            noise = pins.map(" line719="                noise," line720="                15," line721="                32," line722="                60," line723="                70" line724="            )" line725="        } else if (noise &lt;= 60) {" line726="            noise = pins.map(" line727="                noise," line728="                33," line729="                60," line730="                70," line731="                75" line732="            )" line733="        } else if (noise &lt;= 100) {" line734="            noise = pins.map(" line735="                noise," line736="                61," line737="                100," line738="                75," line739="                80" line740="            )" line741="        } else if (noise &lt;= 150) {" line742="            noise = pins.map(" line743="                noise," line744="                101," line745="                150," line746="                80," line747="                85" line748="            )" line749="        } else if (noise &lt;= 231) {" line750="            noise = pins.map(" line751="                noise," line752="                151," line753="                231," line754="                85," line755="                90" line756="            )" line757="        } else {" line758="            noise = pins.map(" line759="                noise," line760="                231," line761="                1023," line762="                90," line763="                120" line764="            )" line765="        }" line766="        noise = Math.round(noise)" line767="        return Math.round(noise)" line768="    }" line769="" line770="    export class GroveJoystick" line771="    {" line772="        /**" line773="         * Detect position from Grove - Thumb Joystick" line774="         * @param xPin" line775="         * @param yPin" line776="         */" line777="     " line778="        joyread(xPin: AnalogPin, yPin: AnalogPin): number {" line779="" line780="            let xdata = 0, ydata = 0, result = 0;" line781="            if (xPin &amp;&amp; yPin) {" line782="                xdata = pins.analogReadPin(xPin);" line783="                ydata = pins.analogReadPin(yPin);" line784="                if (xdata &gt; 1000) {" line785="                    result = GroveJoystickKey.Press;" line786="                }" line787="                else if (xdata &gt; 600) {" line788="                    if (ydata &gt; 600) result = GroveJoystickKey.UR;" line789="                    else if (ydata &lt; 400) result = GroveJoystickKey.LR;" line790="                    else result = GroveJoystickKey.Right;" line791="                }" line792="                else if (xdata &lt; 400) {" line793="                    if (ydata &gt; 600) result = GroveJoystickKey.UL;" line794="                    else if (ydata &lt; 400) result = GroveJoystickKey.LL;" line795="                    else result = GroveJoystickKey.Left;" line796="                }" line797="                else {" line798="                    if (ydata &gt; 600) result = GroveJoystickKey.Up;" line799="                    else if (ydata &lt; 400) result = GroveJoystickKey.Down;" line800="                    else result = GroveJoystickKey.None;" line801="                }" line802="            }" line803="            else {" line804="                result =  GroveJoystickKey.None;" line805="            }" line806="            return result;" line807="        }" line808="    }" line809="    " line810="    const joystickEventID = 3101;" line811="    let lastJoystick = GroveJoystickKey.None;" line812="    let joystick = new GroveJoystick();" line813="    /**" line814="     * get Joystick key" line815="     * " line816="     */" line817="    //% blockId=grove_getjoystick block=&quot;get joystick key at|%xpin|and|%ypin&quot;" line818="    //% xpin.fieldEditor=&quot;gridpicker&quot;" line819="    //% xpin.fieldOptions.columns=3" line820="    //% ypin.fieldEditor=&quot;gridpicker&quot;" line821="    //% ypin.fieldOptions.columns=3" line822="    //% group=&quot;Thumb Joystick&quot; xpin.defl=AnalogPin.C16 ypin.defl=AnalogPin.C17" line823="    //% subcategory=Input  color=#851DE8 " line824="    export function getJoystick(xpin: AnalogPin, ypin: AnalogPin): number {" line825="        return joystick.joyread(xpin, ypin);" line826="    }" line827="" line828="    /**" line829="     * Converts the key name to a number" line830="     * Useful for comparisons" line831="     */" line832="    //% blockId=joystickkey block=&quot;%key&quot;" line833="    //% key.fieldEditor=&quot;gridpicker&quot;" line834="    //% key.fieldOptions.columns=2" line835="    //% group=&quot;Thumb Joystick&quot;" line836="    //% subcategory=Input  color=#851DE8 " line837="" line838="    export function joystickkey(key: GroveJoystickKey): number {" line839="        return key;" line840="    }" line841="" line842="    /**" line843="     * Do something when a key is detected by Grove - Thumb Joystick" line844="     * @param key type of joystick to detect" line845="     * @param xpin" line846="     * @param ypin" line847="     * @param handler code to run" line848="     */" line849="    //% blockId=grove_joystick_create_event block=&quot;on key|%key at |%xpin|and|%ypin&quot;" line850="    //% key.fieldEditor=&quot;gridpicker&quot;" line851="    //% key.fieldOptions.columns=2" line852="    //% xpin.fieldEditor=&quot;gridpicker&quot;" line853="    //% xpin.fieldOptions.columns=3" line854="    //% ypin.fieldEditor=&quot;gridpicker&quot;" line855="    //% ypin.fieldOptions.columns=3" line856="    //% group=&quot;Thumb Joystick&quot; xpin.defl=AnalogPin.C16 ypin.defl=AnalogPin.C17" line857="    //% subcategory=Input  color=#851DE8 " line858="" line859="    export function onJoystick(key: GroveJoystickKey, xpin: AnalogPin, ypin: AnalogPin, handler: () =&gt; void) {" line860="        control.onEvent(joystickEventID, key, handler);" line861="        control.inBackground(() =&gt; {" line862="            while(true) {" line863="                const key = joystick.joyread(xpin, ypin);" line864="                if (key != lastJoystick) {" line865="                    lastJoystick = key; " line866="                    control.raiseEvent(joystickEventID, lastJoystick);" line867="                }" line868="                basic.pause(50);" line869="            }" line870="        })" line871="        " line872="    }" line873="" line874="    /**" line875="     * Get analog potentiometer value [0-1023]" line876="    */" line877="    //% blockId=hackbitPotargRead" line878="    //% block=&quot;potentiometer pin |%pin| value&quot;" line879="    //% subcategory=Input  group=&quot;Analog&quot; color=#851DE8 icon=&quot;\uf1eb&quot;" line880="    export function potarValue(pin: AnalogPin): number {" line881="        return pins.analogReadPin(pin);" line882="    }" line883="" line884="    /**" line885="     * Get rotary angle sensor [0-300]" line886="    */" line887="    //% blockId=hackbitRotaryRead" line888="    //% block=&quot;rotary angle sensor pin |%pin| value&quot;" line889="    //% subcategory=Input  group=&quot;Analog&quot; color=#851DE8 icon=&quot;\uf1eb&quot;" line890="    export function rotaryValue(pin: AnalogPin): number {" line891="        let tRotaryAngle = pins.analogReadPin(pin)" line892="        let RotaryAngle" line893="        RotaryAngle = pins.map(" line894="            tRotaryAngle," line895="            0," line896="            1023," line897="            0," line898="            300" line899="        );" line900="        return Math.round(RotaryAngle)" line901="    }" line902="" line903="    /**" line904="     * Set Led state" line905="    */" line906="    //% blockId=hackbitLedSet" line907="    //% block=&quot;led |%pin| to |%state|&quot;" line908="    //% state.min=0 state.max=1" line909="    //% subcategory=Display  group=&quot;Digital&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line910="    export function ledState(pin: DigitalPin, state: OnOff): void {" line911="        pins.digitalWritePin(pin, state);" line912="    }" line913="" line914="    /**" line915="    * Get color from I2C Grove Color Sensor v1.3 (TCS3414CS) or v2.0 (TCS3472)" line916="    * [0;65534]" line917="    * @param selected color" line918="    */" line919="    //% blockId=&quot;grovecolorsensorgetcolor&quot; " line920="    //% block=&quot;color sensor detected %Color&quot;" line921="    //% block.loc.fr=&quot;Valeur de la couleur %Color du capteur de couleur grove&quot;" line922="    //% jsdoc = &quot;Grab sensor value from grove color sensor&quot;" line923="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line924="" line925="    export function color(col: Color): NumberFormat.UInt16BE {" line926="        let nums, red, green, blue, clear: number;" line927="" line928="        if (identifiant == 0) {   // No sensor previously detected" line929="            pins.i2cWriteNumber(57, 132, NumberFormat.UInt8BE, false);" line930="            nums = pins.i2cReadNumber(57, NumberFormat.UInt8BE, false);" line931="            if (nums == 17) {     // Grove Sensor v1.3 detected" line932="                identifiant = 1;" line933="                pins.i2cWriteNumber(57, 129, NumberFormat.UInt8BE, false);" line934="                pins.i2cWriteNumber(57, 0, NumberFormat.UInt8BE, true);" line935="                pins.i2cWriteNumber(57, 135, NumberFormat.UInt8BE, false);" line936="                pins.i2cWriteNumber(57, 48, NumberFormat.UInt8BE, true);" line937="                pins.i2cWriteNumber(57, 128, NumberFormat.UInt8BE, false);" line938="                pins.i2cWriteNumber(57, 3, NumberFormat.UInt8BE, true);" line939="                basic.pause(50);" line940="            } else {" line941="                pins.i2cWriteNumber(41, 146, NumberFormat.UInt8BE, false);" line942="                nums = pins.i2cReadNumber(41, NumberFormat.UInt8BE, false);" line943="                if (nums == 68) {     // Grove Sensor v2 detected " line944="                    identifiant = 2;" line945="                    pins.i2cWriteNumber(41, 129, NumberFormat.UInt8BE, false);" line946="                    pins.i2cWriteNumber(41, 249, NumberFormat.UInt8BE, true);" line947="                    pins.i2cWriteNumber(41, 143, NumberFormat.UInt8BE, false);" line948="                    pins.i2cWriteNumber(41, 2, NumberFormat.UInt8BE, true);" line949="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line950="                    pins.i2cWriteNumber(41, 1, NumberFormat.UInt8BE, true);" line951="                    basic.pause(50);" line952="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line953="                    pins.i2cWriteNumber(41, 3, NumberFormat.UInt8BE, true);" line954="                    basic.pause(500);" line955="                }" line956="            }" line957="        }" line958="" line959="        if (identifiant == 1) {    // Grove Sensor v1.3 detected" line960="            switch (col) {" line961="                case Color.Red:" line962="                    pins.i2cWriteNumber(57, 210, NumberFormat.UInt8BE, false);" line963="                    red = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line964="                    return swap16(red)" line965="                    break" line966="                case Color.Green:" line967="                    pins.i2cWriteNumber(57, 208, NumberFormat.UInt8BE, false);" line968="                    green = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line969="                    return swap16(green)" line970="                    break" line971="                case Color.Blue:" line972="                    pins.i2cWriteNumber(57, 212, NumberFormat.UInt8BE, false);" line973="                    blue = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line974="                    return swap16(blue)" line975="                    break" line976="                case Color.Clear:" line977="                    pins.i2cWriteNumber(57, 214, NumberFormat.UInt8BE, false);" line978="                    clear = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line979="                    return swap16(clear)" line980="                    break" line981="            }" line982="        }" line983="        else if (identifiant == 2) {" line984="            switch (col) {" line985="                case Color.Red:" line986="                    pins.i2cWriteNumber(41, 150, NumberFormat.UInt8BE, false);" line987="                    red = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line988="                    return swap16(red)" line989="                    break" line990="                case Color.Green:" line991="                    pins.i2cWriteNumber(41, 152, NumberFormat.UInt8BE, false);" line992="                    green = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line993="                    return swap16(green)" line994="                    break" line995="                case Color.Blue:" line996="                    pins.i2cWriteNumber(41, 154, NumberFormat.UInt8BE, false);" line997="                    blue = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line998="                    return swap16(blue)" line999="                    break" line1000="                case Color.Clear:" line1001="                    pins.i2cWriteNumber(41, 148, NumberFormat.UInt8BE, false);" line1002="                    clear = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line1003="                    return swap16(clear)" line1004="                    break" line1005="            }" line1006="            return 0;" line1007="        }" line1008="        return 0;" line1009="    }" line1010="" line1011="    /**" line1012="    * Read color from I2C APDS9960 Color Sensor [0;360]" line1013="    */" line1014="    //% blockId=apds9960_readcolor block=&quot;APDS9960 get color HUE (0~360)&quot;" line1015="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    &#9;" line1016="&#9;" line1017="    export function readColor(): number {" line1018="        if (color_first_init == false) {" line1019="            initModule()" line1020="            colorMode()" line1021="        }" line1022="        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) &amp; 0x1;" line1023="        while (!tmp) {" line1024="            basic.pause(5);" line1025="            tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) &amp; 0x1;" line1026="        }" line1027="        let c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;" line1028="        let r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;" line1029="        let g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;" line1030="        let b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;" line1031="        // map to rgb based on clear channel" line1032="        let avg = c / 3;" line1033="        r = r * 255 / avg;" line1034="        g = g * 255 / avg;" line1035="        b = b * 255 / avg;" line1036="        //let hue = rgb2hue(r, g, b);" line1037="        let hue = rgb2hsl(r, g, b)" line1038="        return hue" line1039="    }" line1040="" line1041="    /**" line1042="    * Read color from I2C APDS9960 Color Sensor " line1043="    * @param selected color" line1044="    */" line1045="    //% block=&quot;APDS9960 color sensor %color detects&quot;" line1046="    //% subcategory=Sensor group=&quot;IIC Port&quot;" line1047="    //% color.fieldEditor=&quot;gridpicker&quot; color.fieldOptions.columns=3" line1048="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    &#9;" line1049="" line1050="    export function checkColor(color: ColorList): boolean {" line1051="        let hue2 = readColor()" line1052="        switch (color) {" line1053="            case ColorList.red:" line1054="                if (hue2 &gt; 330 || hue2 &lt; 20) {" line1055="                    return true" line1056="                }" line1057="                else {" line1058="                    return false" line1059="                }" line1060="                break" line1061="            case ColorList.green:" line1062="                if (hue2 &gt; 110 &amp;&amp; 150 &gt; hue2) {" line1063="                    return true" line1064="                }" line1065="                else {" line1066="                    return false" line1067="                }" line1068="                break" line1069="            case ColorList.blue:" line1070="                if (hue2 &gt; 200 &amp;&amp; 270 &gt; hue2) {" line1071="                    return true" line1072="                }" line1073="                else {" line1074="                    return false" line1075="                }" line1076="                break" line1077="            case ColorList.cyan:" line1078="                if (hue2 &gt; 160 &amp;&amp; 180 &gt; hue2) {" line1079="                    return true" line1080="                }" line1081="                else {" line1082="                    return false" line1083="                }" line1084="                break" line1085="            case ColorList.magenta:" line1086="                if (hue2 &gt; 260 &amp;&amp; 330 &gt; hue2) {" line1087="                    return true" line1088="                }" line1089="                else {" line1090="                    return false" line1091="                }" line1092="                break" line1093="            case ColorList.yellow:" line1094="                if (hue2 &gt; 30 &amp;&amp; 90 &gt; hue2) {" line1095="                    return true" line1096="                }" line1097="                else {" line1098="                    return false" line1099="                }" line1100="                break" line1101="            case ColorList.white:" line1102="                if (hue2 &gt;= 180 &amp;&amp; 200 &gt; hue2) {" line1103="                    return true" line1104="                }" line1105="                else {" line1106="                    return false" line1107="                }" line1108="                break" line1109="        }" line1110="    }" line1111="" line1112="    export class PAJ7620 {" line1113="        private paj7620WriteReg(addr: number, cmd: number) {" line1114="            let buf: Buffer = pins.createBuffer(2);" line1115="            buf[0] = addr;" line1116="            buf[1] = cmd;" line1117="            pins.i2cWriteBuffer(0x73, buf, false);" line1118="        }" line1119="        private paj7620ReadReg(addr: number): number {" line1120="            let buf2: Buffer = pins.createBuffer(1);" line1121="            buf2[0] = addr;" line1122="            pins.i2cWriteBuffer(0x73, buf2, false);" line1123="            buf2 = pins.i2cReadBuffer(0x73, 1, false);" line1124="            return buf2[0];" line1125="        }" line1126="        private paj7620SelectBank(bank: number) {" line1127="            if (bank == 0) this.paj7620WriteReg(0xEF, 0);" line1128="            else if (bank == 1) this.paj7620WriteReg(0xEF, 1);" line1129="        }" line1130="        private paj7620Init() {" line1131="            let temp2 = 0;" line1132="            this.paj7620SelectBank(0);" line1133="            temp2 = this.paj7620ReadReg(0);" line1134="            if (temp2 == 0x20) {" line1135="                for (let o = 0; o &lt; 438; o += 2) {" line1136="                    this.paj7620WriteReg(initRegisterArray[o], initRegisterArray[o + 1]);" line1137="                }" line1138="            }" line1139="            this.paj7620SelectBank(0);" line1140="        }" line1141="        init() {" line1142="            this.paj7620Init();" line1143="            basic.pause(200);" line1144="        }" line1145="        read(): number {" line1146="            let data = 0, result2 = 0;" line1147="            data = this.paj7620ReadReg(0x43);" line1148="            switch (data) {" line1149="                case 0x01:" line1150="                    result2 = GroveGesture.Right;" line1151="                    break;" line1152="                case 0x02:" line1153="                    result2 = GroveGesture.Left;" line1154="                    break;" line1155="                case 0x04:" line1156="                    result2 = GroveGesture.Up;" line1157="                    break;" line1158="                case 0x08:" line1159="                    result2 = GroveGesture.Down;" line1160="                    break;" line1161="                case 0x10:" line1162="                    result2 = GroveGesture.Forward;" line1163="                    break;" line1164="                case 0x20:" line1165="                    result2 = GroveGesture.Backward;" line1166="                    break;" line1167="                case 0x40:" line1168="                    result2 = GroveGesture.Clockwise;" line1169="                    break;" line1170="                case 0x80:" line1171="                    result2 = GroveGesture.Anticlockwise;" line1172="                    break;" line1173="                default:" line1174="                    data = this.paj7620ReadReg(0x44);" line1175="                    if (data == 0x01)" line1176="                        result2 = GroveGesture.Wave;" line1177="                    break;" line1178="            }" line1179="            return result2;" line1180="        }" line1181="    }        " line1182="" line1183="    const gestureEventId = 3100;" line1184="    let lastGesture = GroveGesture.None;" line1185="    let paj7620 = new PAJ7620();" line1186="    /**" line1187="        * Do something when a gesture is detected" line1188="        * @param gesture type of gesture to detect" line1189="        * @param handler code to run" line1190="    */" line1191="    //% blockId= gesture_create_event block=&quot;on gesture sensor is %gesture&quot;" line1192="    //% gesture.fieldEditor=&quot;gridpicker&quot; gesture.fieldOptions.columns=3" line1193="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line1194="    export function onGesture(gesture: GroveGesture, handler: () =&gt; void) {" line1195="        control.onEvent(gestureEventId, gesture, handler);" line1196="        if(gesture_first_init){" line1197="            paj7620.init();" line1198="            gesture_first_init = false" line1199="        }" line1200="        control.inBackground(() =&gt; {" line1201="            while (true) {" line1202="                const gesture = paj7620.read();" line1203="                if (gesture != lastGesture) {" line1204="                    lastGesture = gesture;" line1205="                    control.raiseEvent(gestureEventId, lastGesture);" line1206="                }" line1207="                basic.pause(100);" line1208="            }" line1209="        })" line1210="    }" line1211="" line1212="    /**" line1213="     * Create a new driver Grove - 4-Digit Display" line1214="     * @param clkPin value of clk pin number" line1215="     * @param dataPin value of data pin number" line1216="     */" line1217="    //% blockId=hackbit_tm1637_create block=&quot;4-Digit Display at|%clkPin|and|%dataPin&quot;" line1218="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1219="    //% weight=60" line1220="    export function digit_createDisplay(clkPin: DigitalPin, dataPin: DigitalPin): void {" line1221="        digit_buf = pins.createBuffer(4);" line1222="        digit_clkPin = clkPin;" line1223="        digit_dataPin = dataPin;" line1224="        digit_brightnessLevel = 0;" line1225="        digit_pointFlag = false;" line1226="        digit_clear();" line1227="    }" line1228="" line1229="    /**" line1230="    * Show a 4 digits number on display" line1231="    * @param dispData value of number" line1232="    */" line1233="    //% blockId=hackbit_tm1637_display_number block=&quot;show number|%dispData&quot;" line1234="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1235="    //% weight=59" line1236="    export function digit_show(dispData: number) {" line1237="        let compare_01: number = dispData % 100;" line1238="        let compare_001: number = dispData % 1000;" line1239="" line1240="        if (dispData &lt; 10) {" line1241="            digit_bit(dispData, 3);" line1242="            digit_bit(0x7f, 2);" line1243="            digit_bit(0x7f, 1);" line1244="            digit_bit(0x7f, 0);" line1245="        }" line1246="        else if (dispData &lt; 100) {" line1247="            digit_bit(dispData % 10, 3);" line1248="            if (dispData &gt; 90) {" line1249="                digit_bit(9, 2);" line1250="            } else {" line1251="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line1252="            }" line1253="" line1254="            digit_bit(0x7f, 1);" line1255="            digit_bit(0x7f, 0);" line1256="        }" line1257="        else if (dispData &lt; 1000) {" line1258="            digit_bit(dispData % 10, 3);" line1259="            if (compare_01 &gt; 90) {" line1260="                digit_bit(9, 2);" line1261="            } else {" line1262="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line1263="            }" line1264="            if (compare_001 &gt; 900) {" line1265="                digit_bit(9, 1);" line1266="            } else {" line1267="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line1268="            }" line1269="            digit_bit(0x7f, 0);" line1270="        }" line1271="        else if (dispData &lt; 10000) {" line1272="            digit_bit(dispData % 10, 3);" line1273="            if (compare_01 &gt; 90) {" line1274="                digit_bit(9, 2);" line1275="            } else {" line1276="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line1277="            }" line1278="            if (compare_001 &gt; 900) {" line1279="                digit_bit(9, 1);" line1280="            } else {" line1281="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line1282="            }" line1283="            if (dispData &gt; 9000) {" line1284="                digit_bit(9, 0);" line1285="            } else {" line1286="                digit_bit(Math.floor(dispData / 1000) % 10, 0);" line1287="            }" line1288="        }" line1289="        else {" line1290="            digit_bit(9, 3);" line1291="            digit_bit(9, 2);" line1292="            digit_bit(9, 1);" line1293="            digit_bit(9, 0);" line1294="        }" line1295="    }" line1296="" line1297="    /**" line1298="     * Set the brightness level of display at from 0 to 7" line1299="     * @param level value of brightness light level" line1300="     */" line1301="    //% blockId=hackbit_tm1637_set_display_level block=&quot;brightness level to|%level&quot;" line1302="    //% level.min=0 level.max=7" line1303="    //% weight=58" line1304="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;     " line1305="    export function digit_set(level: number) {" line1306="        digit_brightnessLevel = level;" line1307="" line1308="        digit_bit(digit_buf[0], 0x00);" line1309="        digit_bit(digit_buf[1], 0x01);" line1310="        digit_bit(digit_buf[2], 0x02);" line1311="        digit_bit(digit_buf[3], 0x03);" line1312="    }" line1313="" line1314="    /**" line1315="     * Show a single number from 0 to 9 at a specified digit of Grove - 4-Digit Display" line1316="     * @param dispData value of number" line1317="     * @param bitAddr value of bit number" line1318="     */" line1319="    //% blockId=grove_tm1637_display_bit block=&quot;%strip|show single number|%dispData|at digit|%bitAddr&quot;" line1320="    //% dispData.min=0 dispData.max=9" line1321="    //% bitAddr.min=0 bitAddr.max=3" line1322="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1323="    //% advanced=false" line1324="    export function digit_bit(dispData: number, bitAddr: number) {" line1325="        if ((dispData == 0x7f) || ((dispData &lt;= 9) &amp;&amp; (bitAddr &lt;= 3))) {" line1326="            let segData = 0;" line1327="" line1328="            segData = digit_coding(dispData);" line1329="            digit_start();" line1330="            digit_writeByte(0x44);" line1331="            digit_stop();" line1332="            digit_start();" line1333="            digit_writeByte(bitAddr | 0xc0);" line1334="            digit_writeByte(segData);" line1335="            digit_stop();" line1336="            digit_start();" line1337="            digit_writeByte(0x88 + digit_brightnessLevel);" line1338="            digit_stop();" line1339="" line1340="            digit_buf[bitAddr] = dispData;" line1341="        }" line1342="    }" line1343="" line1344="    /**" line1345="     * Turn on or off the colon point on Grove - 4-Digit Display" line1346="     * @param pointEn value of point switch" line1347="     */" line1348="    //% blockId=grove_tm1637_display_point block=&quot;%strip|turn|%point|colon point&quot;" line1349="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;   " line1350="    //% advanced=false" line1351="    export function digit_point(point: boolean) {" line1352="        digit_pointFlag = point;" line1353="" line1354="        digit_bit(digit_buf[0], 0x00);" line1355="        digit_bit(digit_buf[1], 0x01);" line1356="        digit_bit(digit_buf[2], 0x02);" line1357="        digit_bit(digit_buf[3], 0x03);" line1358="    }" line1359="" line1360="    /**" line1361="     * Clear the display" line1362="     */" line1363="    //% blockId=grove_tm1637_display_clear block=&quot;%strip|clear&quot;" line1364="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1365="    //% advanced=false" line1366="    export function digit_clear() {" line1367="        digit_bit(0x7f, 0x00);" line1368="        digit_bit(0x7f, 0x01);" line1369="        digit_bit(0x7f, 0x02);" line1370="        digit_bit(0x7f, 0x03);" line1371="    }" line1372="" line1373="    /*" line1374="     * Private functions" line1375="     */" line1376="    function swap16(val: NumberFormat.UInt16BE) {" line1377="        return ((val &amp; 0xFF) &lt;&lt; 8)" line1378="            | ((val &gt;&gt; 8) &amp; 0xFF);" line1379="    }" line1380="" line1381="    function digit_writeByte(wrData: number) {" line1382="        for (let p = 0; p &lt; 8; p++) {" line1383="            pins.digitalWritePin(digit_clkPin, 0);" line1384="            if (wrData &amp; 0x01) pins.digitalWritePin(digit_dataPin, 1);" line1385="            else pins.digitalWritePin(digit_dataPin, 0);" line1386="            wrData &gt;&gt;= 1;" line1387="            pins.digitalWritePin(digit_clkPin, 1);" line1388="        }" line1389="" line1390="        pins.digitalWritePin(digit_clkPin, 0); // Wait for ACK" line1391="        pins.digitalWritePin(digit_dataPin, 1);" line1392="        pins.digitalWritePin(digit_clkPin, 1);" line1393="    }" line1394="" line1395="    function digit_start() {" line1396="        pins.digitalWritePin(digit_clkPin, 1);" line1397="        pins.digitalWritePin(digit_dataPin, 1);" line1398="        pins.digitalWritePin(digit_dataPin, 0);" line1399="        pins.digitalWritePin(digit_clkPin, 0);" line1400="    }" line1401="" line1402="    function digit_stop() {" line1403="        pins.digitalWritePin(digit_clkPin, 0);" line1404="        pins.digitalWritePin(digit_dataPin, 0);" line1405="        pins.digitalWritePin(digit_clkPin, 1);" line1406="        pins.digitalWritePin(digit_dataPin, 1);" line1407="    }" line1408="" line1409="    function digit_coding(dispData: number): number {" line1410="        let pointData = 0;" line1411="" line1412="        if (digit_pointFlag == true) pointData = 0x80;" line1413="        else if (digit_pointFlag == false) pointData = 0;" line1414="" line1415="        if (dispData == 0x7f) dispData = 0x00 + pointData;" line1416="        else dispData = TubeTab[dispData] + pointData;" line1417="" line1418="        return dispData;" line1419="    }" line1420="" line1421="    /***********   APDS 9960  **********/" line1422="    function i2cwrite_color(addr: number, reg: number, value: number) {" line1423="        let buf3 = pins.createBuffer(2)" line1424="        buf3[0] = reg" line1425="        buf3[1] = value" line1426="        pins.i2cWriteBuffer(addr, buf3)" line1427="    }" line1428="" line1429="    function i2cread_color(addr: number, reg: number) {" line1430="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line1431="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line1432="        return val;" line1433="    }" line1434="" line1435="    function rgb2hsl(color_r: number, color_g: number, color_b: number): number {" line1436="        let Hue = 0" line1437="        // Convert the RGB value to the middle value of [0, 1]." line1438="        let R2 = color_r * 100 / 255;   //Since H25 does not support floating point operations, it is calculated by zooming 100 times, and the following calculations are also zooming 100 times" line1439="        let G = color_g * 100 / 255;" line1440="        let B2 = color_b * 100 / 255;" line1441="" line1442="        let maxVal = Math.max(R2, Math.max(G, B2))//Find the maximum of R, G, and B" line1443="        let minVal = Math.min(R2, Math.min(G, B2)) //Find the minimum of R, G and B" line1444="" line1445="        let Delta = maxVal - minVal;  //△ = Max - Min" line1446="" line1447="        /***********   Calculate Hue  **********/" line1448="        if (Delta &lt; 0) {" line1449="            Hue = 0;" line1450="        }" line1451="        else if (maxVal == R2 &amp;&amp; G &gt;= B2) //Maximum value is red" line1452="        {" line1453="            Hue = (60 * ((G - B2) * 100 / Delta)) / 100;  //Magnify 100 times" line1454="        }" line1455="        else if (maxVal == R2 &amp;&amp; G &lt; B2) {" line1456="            Hue = (60 * ((G - B2) * 100 / Delta) + 360 * 100) / 100;" line1457="        }" line1458="        else if (maxVal == G) //Maximum value is green" line1459="        {" line1460="            Hue = (60 * ((B2 - R2) * 100 / Delta) + 120 * 100) / 100;" line1461="        }" line1462="        else if (maxVal == B2) {" line1463="            Hue = (60 * ((R2 - G) * 100 / Delta) + 240 * 100) / 100;" line1464="        }" line1465="        return Hue" line1466="    }" line1467="" line1468="    function initModule(): void {" line1469="        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252) // default inte time 4x2.78ms" line1470="        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03) // todo: make gain adjustable" line1471="        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00) // put everything off" line1472="        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00) // disable gesture mode" line1473="        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00) // clear all interrupt" line1474="        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01) // clear all interrupt" line1475="        color_first_init = true" line1476="    }" line1477="" line1478="    function colorMode(): void {" line1479="        let tmp2 = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;" line1480="        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp2);" line1481="    }" line1482="}" numlines="1483"></mutation></block></statement></block></xml>