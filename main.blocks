<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="+TVaI*ic@T:VH8}^m(%F" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id=",UDqh[UGVsr@T_F(qVFT" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace hackbit {" line1="    const initRegisterArray: number[] = [" line2="        0xEF, 0x00, 0x32, 0x29, 0x33, 0x01, 0x34, 0x00, 0x35, 0x01, 0x36, 0x00, 0x37, 0x07, 0x38, 0x17," line3="        0x39, 0x06, 0x3A, 0x12, 0x3F, 0x00, 0x40, 0x02, 0x41, 0xFF, 0x42, 0x01, 0x46, 0x2D, 0x47, 0x0F," line4="        0x48, 0x3C, 0x49, 0x00, 0x4A, 0x1E, 0x4B, 0x00, 0x4C, 0x20, 0x4D, 0x00, 0x4E, 0x1A, 0x4F, 0x14," line5="        0x50, 0x00, 0x51, 0x10, 0x52, 0x00, 0x5C, 0x02, 0x5D, 0x00, 0x5E, 0x10, 0x5F, 0x3F, 0x60, 0x27," line6="        0x61, 0x28, 0x62, 0x00, 0x63, 0x03, 0x64, 0xF7, 0x65, 0x03, 0x66, 0xD9, 0x67, 0x03, 0x68, 0x01," line7="        0x69, 0xC8, 0x6A, 0x40, 0x6D, 0x04, 0x6E, 0x00, 0x6F, 0x00, 0x70, 0x80, 0x71, 0x00, 0x72, 0x00," line8="        0x73, 0x00, 0x74, 0xF0, 0x75, 0x00, 0x80, 0x42, 0x81, 0x44, 0x82, 0x04, 0x83, 0x20, 0x84, 0x20," line9="        0x85, 0x00, 0x86, 0x10, 0x87, 0x00, 0x88, 0x05, 0x89, 0x18, 0x8A, 0x10, 0x8B, 0x01, 0x8C, 0x37," line10="        0x8D, 0x00, 0x8E, 0xF0, 0x8F, 0x81, 0x90, 0x06, 0x91, 0x06, 0x92, 0x1E, 0x93, 0x0D, 0x94, 0x0A," line11="        0x95, 0x0A, 0x96, 0x0C, 0x97, 0x05, 0x98, 0x0A, 0x99, 0x41, 0x9A, 0x14, 0x9B, 0x0A, 0x9C, 0x3F," line12="        0x9D, 0x33, 0x9E, 0xAE, 0x9F, 0xF9, 0xA0, 0x48, 0xA1, 0x13, 0xA2, 0x10, 0xA3, 0x08, 0xA4, 0x30," line13="        0xA5, 0x19, 0xA6, 0x10, 0xA7, 0x08, 0xA8, 0x24, 0xA9, 0x04, 0xAA, 0x1E, 0xAB, 0x1E, 0xCC, 0x19," line14="        0xCD, 0x0B, 0xCE, 0x13, 0xCF, 0x64, 0xD0, 0x21, 0xD1, 0x0F, 0xD2, 0x88, 0xE0, 0x01, 0xE1, 0x04," line15="        0xE2, 0x41, 0xE3, 0xD6, 0xE4, 0x00, 0xE5, 0x0C, 0xE6, 0x0A, 0xE7, 0x00, 0xE8, 0x00, 0xE9, 0x00," line16="        0xEE, 0x07, 0xEF, 0x01, 0x00, 0x1E, 0x01, 0x1E, 0x02, 0x0F, 0x03, 0x10, 0x04, 0x02, 0x05, 0x00," line17="        0x06, 0xB0, 0x07, 0x04, 0x08, 0x0D, 0x09, 0x0E, 0x0A, 0x9C, 0x0B, 0x04, 0x0C, 0x05, 0x0D, 0x0F," line18="        0x0E, 0x02, 0x0F, 0x12, 0x10, 0x02, 0x11, 0x02, 0x12, 0x00, 0x13, 0x01, 0x14, 0x05, 0x15, 0x07," line19="        0x16, 0x05, 0x17, 0x07, 0x18, 0x01, 0x19, 0x04, 0x1A, 0x05, 0x1B, 0x0C, 0x1C, 0x2A, 0x1D, 0x01," line20="        0x1E, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x25, 0x01, 0x26, 0x00, 0x27, 0x39, 0x28, 0x7F," line21="        0x29, 0x08, 0x30, 0x03, 0x31, 0x00, 0x32, 0x1A, 0x33, 0x1A, 0x34, 0x07, 0x35, 0x07, 0x36, 0x01," line22="        0x37, 0xFF, 0x38, 0x36, 0x39, 0x07, 0x3A, 0x00, 0x3E, 0xFF, 0x3F, 0x00, 0x40, 0x77, 0x41, 0x40," line23="        0x42, 0x00, 0x43, 0x30, 0x44, 0xA0, 0x45, 0x5C, 0x46, 0x00, 0x47, 0x00, 0x48, 0x58, 0x4A, 0x1E," line24="        0x4B, 0x1E, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0xA0, 0x4F, 0x80, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00," line25="        0x53, 0x00, 0x54, 0x00, 0x57, 0x80, 0x59, 0x10, 0x5A, 0x08, 0x5B, 0x94, 0x5C, 0xE8, 0x5D, 0x08," line26="        0x5E, 0x3D, 0x5F, 0x99, 0x60, 0x45, 0x61, 0x40, 0x63, 0x2D, 0x64, 0x02, 0x65, 0x96, 0x66, 0x00," line27="        0x67, 0x97, 0x68, 0x01, 0x69, 0xCD, 0x6A, 0x01, 0x6B, 0xB0, 0x6C, 0x04, 0x6D, 0x2C, 0x6E, 0x01," line28="        0x6F, 0x32, 0x71, 0x00, 0x72, 0x01, 0x73, 0x35, 0x74, 0x00, 0x75, 0x33, 0x76, 0x31, 0x77, 0x01," line29="        0x7C, 0x84, 0x7D, 0x03, 0x7E, 0x01" line30="    ];" line31="" line32="/**" line33="* Sempre adicionar ao inicio de main.ts antes de submeter" line34="**/" line35="" line36="/**" line37=" * Library for Grove micro:bit project board https://www.hackids.com.br" line38="*/" line39="/** " line40="* //% weight=10 color=#FF1344 icon=&quot;\uf135&quot;" line41="**/" line42="" line43="    export enum MotorDirection {" line44="        //% block=&quot;Forward&quot;" line45="        Forward = 1," line46="        //% block=&quot;Backward&quot;" line47="        Reverse = 2," line48="        //% block=&quot;Stop&quot;" line49="        Stop = 0" line50="    }" line51="" line52="    export enum OnOff {" line53="        //% block=&quot;On&quot;" line54="        On = 1," line55="        //% block=&quot;Off&quot;" line56="        Off = 0" line57="    }" line58="" line59="    export enum BP {" line60="        //% block=&quot;BPA&quot;" line61="        BPA = 1," line62="        //% block=&quot;BPB&quot;" line63="        BPB = 0" line64="    }" line65="" line66="    export enum RobotDirection {" line67="        //% block=&quot;Forward&quot;" line68="        Forward," line69="        //% block=&quot;Backward&quot;" line70="        Reverse," line71="        //% block=&quot;Turn Right&quot;" line72="        TurnRigh," line73="        //% block=&quot;Turn Left&quot;" line74="        TurnLef," line75="        //% block=&quot;Rotate Right&quot;" line76="        RotateRight," line77="        //% block=&quot;Rotate Left&quot;" line78="        RotateLef," line79="        //% block=&quot;Stop&quot;" line80="        Stop" line81="    }" line82="" line83="    export enum Motors {" line84="        //%blockId=A4_Robot_Driver_motor_one" line85="        //% block=&quot;left motor&quot;" line86="        Motor1," line87="        //%blockId=A4_Robot_Driver_motor_two" line88="        //% block=&quot;right motor&quot;" line89="        Motor2," line90="        //%blockId=A4_Robot_Driver_motor_full" line91="        //% block=&quot;left and right motor&quot;" line92="        MotorFull" line93="    }" line94="" line95="    export enum Color {" line96="        //% block=&quot;Red&quot;" line97="        Red," line98="        //% block=&quot;Green&quot;" line99="        Green," line100="        //% block=&quot;Blue&quot;" line101="        Blue," line102="        //% block=&quot;Clear&quot;" line103="        Clear" line104="    }" line105="" line106="    export enum GroveGesture {" line107="        //% block=None" line108="        None = 0," line109="        //% block=Right" line110="        Right = 1," line111="        //% block=Left" line112="        Left = 2," line113="        //% block=Up" line114="        Up = 3," line115="        //% block=Down" line116="        Down = 4," line117="        //% block=Forward" line118="        Forward = 5," line119="        //% block=Backward" line120="        Backward = 6," line121="        //% block=Clockwise" line122="        Clockwise = 7," line123="        //% block=Anticlockwise" line124="        Anticlockwise = 8," line125="        //% block=Wave" line126="        Wave = 9" line127="    }" line128="" line129="    export let identifiant = 0;" line130="    export let grovegestureinit = 0;" line131="" line132="    let TubeTab: number[] = [" line133="        0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07," line134="        0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71" line135="    ];" line136="" line137="    export let digit_clkPin: DigitalPin;" line138="    export let digit_dataPin: DigitalPin;" line139="    export let digit_brightnessLevel: number;" line140="    export let digit_pointFlag: boolean;" line141="    export let digit_buf: Buffer;" line142="" line143="    /**" line144="     * get distance from ultrasonic range sensor [cm]" line145="     * @param pin Input pin" line146="     */" line147="    //% blockId=RobotDriverultrasonic_cm " line148="    //% block=&quot;ultrasonic distance|%name| (cm)&quot;" line149="    //% name.fieldEditor=&quot;gridpicker&quot; " line150="    //% name.fieldOptions.columns=5" line151="    //% name.fieldOptions.tooltips=&quot;false&quot;" line152="    //% name.fieldOptions.width=&quot;0&quot;" line153="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;" line154="    export function measureDistanceCentimeter(name: DigitalPin): number {" line155="        let duration = 0;" line156="        let distance = 0;" line157="        pins.digitalWritePin(name, 0); //make sure pin is low" line158="        control.waitMicros(2);" line159="        pins.digitalWritePin(name, 1); //send echo" line160="        control.waitMicros(20);" line161="        pins.digitalWritePin(name, 0);" line162="        duration = pins.pulseIn(name, PulseValue.High, 50000); // Max duration 50 ms - receive echo" line163="        distance = duration * 153 / 29 / 2 / 100;" line164="        Math.constrain(distance, 0, 500);" line165="        return distance;" line166="    }" line167="" line168="    /**" line169="     * Get line sensor state [0-1]" line170="    */" line171="    //% blockId=hackbitLineRead" line172="    //% block=&quot;line sensor |%pin|&quot;" line173="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line174="    export function detectline(pin: DigitalPin): number {" line175="        return pins.digitalReadPin(pin);" line176="    }" line177="" line178="    /**" line179="     * Get analog potentiometer value [0-1023]" line180="    */" line181="    //% blockId=hackbitPotargRead" line182="    //% block=&quot;potentiometer |%pin|&quot;" line183="    //% subcategory=Input  group=&quot;Analog&quot; color=#851DE8 icon=&quot;\uf1eb&quot;" line184="    export function potarValue(pin: AnalogPin): number {" line185="        return pins.analogReadPin(pin);" line186="    }" line187="" line188="    /**" line189="     * Get collision sensor state [0-1]" line190="    */" line191="    //% blockId=hackbitCollisionRead" line192="    //% block=&quot;collision sensor |%pin|&quot;" line193="    //% subcategory=Input  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line194="    export function collisionSensor(pin: BP): boolean {" line195="        if (pin)" line196="            return input.buttonIsPressed(Button.A);" line197="        return input.buttonIsPressed(Button.B);" line198="    }" line199="" line200="    /**" line201="     * Get button state [0-1]" line202="    */" line203="    //% blockId=hackbitButtonRead" line204="    //% block=&quot;button |%pin|&quot;" line205="    //% subcategory=Input  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line206="    export function buttonState(pin: DigitalPin): number {" line207="        return pins.digitalReadPin(pin);" line208="    }" line209="" line210="    /**" line211="     * Set Led state" line212="    */" line213="    //% blockId=hackbitLedSet" line214="    //% block=&quot;led |%pin| to |%state|&quot;" line215="    //% state.min=0 state.max=1" line216="    //% subcategory=Display  group=&quot;Digital&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line217="    export function ledState(pin: DigitalPin, state: OnOff): void {" line218="        pins.digitalWritePin(pin, state);" line219="    }" line220="" line221="    /**" line222="    * Get color from I2C Grove Color Sensor v1.3 or v2.0" line223="    * [0;65534]" line224="    * @param selected color" line225="    */" line226="    //% blockId=&quot;grovecolorsensorgetcolor&quot; " line227="    //% block=&quot;color %Color&quot;" line228="    //% block.loc.fr=&quot;Valeur de la couleur %Color du capteur de couleur grove&quot;" line229="    //% jsdoc = &quot;Grab sensor value from grove color sensor&quot;" line230="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line231="" line232="    export function color(col: Color): NumberFormat.UInt16BE {" line233="        let nums, red, green, blue, clear: number;" line234="" line235="        if (identifiant == 0) {   // No sensor previously detected" line236="            pins.i2cWriteNumber(57, 132, NumberFormat.UInt8BE, false);" line237="            nums = pins.i2cReadNumber(57, NumberFormat.UInt8BE, false);" line238="            if (nums == 17) {     // Grove Sensor v1.3 detected" line239="                identifiant = 1;" line240="                pins.i2cWriteNumber(57, 129, NumberFormat.UInt8BE, false);" line241="                pins.i2cWriteNumber(57, 0, NumberFormat.UInt8BE, true);" line242="                pins.i2cWriteNumber(57, 135, NumberFormat.UInt8BE, false);" line243="                pins.i2cWriteNumber(57, 48, NumberFormat.UInt8BE, true);" line244="                pins.i2cWriteNumber(57, 128, NumberFormat.UInt8BE, false);" line245="                pins.i2cWriteNumber(57, 3, NumberFormat.UInt8BE, true);" line246="                basic.pause(50);" line247="            } else {" line248="                pins.i2cWriteNumber(41, 146, NumberFormat.UInt8BE, false);" line249="                nums = pins.i2cReadNumber(41, NumberFormat.UInt8BE, false);" line250="                if (nums == 68) {     // Grove Sensor v2 detected " line251="                    identifiant = 2;" line252="                    pins.i2cWriteNumber(41, 129, NumberFormat.UInt8BE, false);" line253="                    pins.i2cWriteNumber(41, 249, NumberFormat.UInt8BE, true);" line254="                    pins.i2cWriteNumber(41, 143, NumberFormat.UInt8BE, false);" line255="                    pins.i2cWriteNumber(41, 2, NumberFormat.UInt8BE, true);" line256="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line257="                    pins.i2cWriteNumber(41, 1, NumberFormat.UInt8BE, true);" line258="                    basic.pause(50);" line259="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line260="                    pins.i2cWriteNumber(41, 3, NumberFormat.UInt8BE, true);" line261="                    basic.pause(500);" line262="                }" line263="            }" line264="        }" line265="" line266="        if (identifiant == 1) {    // Grove Sensor v1.3 detected" line267="            switch (col) {" line268="                case Color.Red:" line269="                    pins.i2cWriteNumber(57, 210, NumberFormat.UInt8BE, false);" line270="                    red = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line271="                    return swap16(red)" line272="                    break" line273="                case Color.Green:" line274="                    pins.i2cWriteNumber(57, 208, NumberFormat.UInt8BE, false);" line275="                    green = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line276="                    return swap16(green)" line277="                    break" line278="                case Color.Blue:" line279="                    pins.i2cWriteNumber(57, 212, NumberFormat.UInt8BE, false);" line280="                    blue = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line281="                    return swap16(blue)" line282="                    break" line283="                case Color.Clear:" line284="                    pins.i2cWriteNumber(57, 214, NumberFormat.UInt8BE, false);" line285="                    clear = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line286="                    return swap16(clear)" line287="                    break" line288="            }" line289="        }" line290="        else if (identifiant == 2) {" line291="            switch (col) {" line292="                case Color.Red:" line293="                    pins.i2cWriteNumber(41, 150, NumberFormat.UInt8BE, false);" line294="                    red = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line295="                    return swap16(red)" line296="                    break" line297="                case Color.Green:" line298="                    pins.i2cWriteNumber(41, 152, NumberFormat.UInt8BE, false);" line299="                    green = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line300="                    return swap16(green)" line301="                    break" line302="                case Color.Blue:" line303="                    pins.i2cWriteNumber(41, 154, NumberFormat.UInt8BE, false);" line304="                    blue = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line305="                    return swap16(blue)" line306="                    break" line307="                case Color.Clear:" line308="                    pins.i2cWriteNumber(41, 148, NumberFormat.UInt8BE, false);" line309="                    clear = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line310="                    return swap16(clear)" line311="                    break" line312="            }" line313="            return 0;" line314="        }" line315="        return 0;" line316="    }" line317="" line318="    /**" line319="     * Detect and recognize the gestures from Grove - Gesture" line320="     * None:0" line321="     * Right:1" line322="     * Left:2" line323="     * Up:3" line324="     * Down:4" line325="     * Forward:5" line326="     * Backward:6" line327="     * Clockwise:7" line328="     * Anticlockwise:8" line329="     * Wave:9" line330="     */" line331="    //% blockId=hackbitGroveGesture" line332="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line333="    export function grove_gesture_reads(): number {" line334="        let data = 0, result = 0;" line335="" line336="        if (grovegestureinit == 0) {" line337="            paj7620Init();" line338="            basic.pause(200);" line339="            grovegestureinit = 1;" line340="        }" line341="" line342="        data = paj7620ReadReg(0x43);" line343="        switch (data) {" line344="            case 0x01:" line345="                result = GroveGesture.Right;" line346="                break;" line347="" line348="            case 0x02:" line349="                result = GroveGesture.Left;" line350="                break;" line351="" line352="            case 0x04:" line353="                result = GroveGesture.Up;" line354="                break;" line355="" line356="            case 0x08:" line357="                result = GroveGesture.Down;" line358="                break;" line359="" line360="            case 0x10:" line361="                result = GroveGesture.Forward;" line362="                break;" line363="" line364="            case 0x20:" line365="                result = GroveGesture.Backward;" line366="                break;" line367="" line368="            case 0x40:" line369="                result = GroveGesture.Clockwise;" line370="                break;" line371="" line372="            case 0x80:" line373="                result = GroveGesture.Anticlockwise;" line374="                break;" line375="" line376="            default:" line377="                data = paj7620ReadReg(0x44);" line378="                if (data == 0x01)" line379="                    result = GroveGesture.Wave;" line380="                break;" line381="        }" line382="        return result;" line383="    }" line384="" line385="    /**" line386="     * Create a new driver Grove - 4-Digit Display" line387="     * @param clkPin value of clk pin number" line388="     * @param dataPin value of data pin number" line389="     */" line390="    //% blockId=hackbit_tm1637_create block=&quot;4-Digit Display at|%clkPin|and|%dataPin&quot;" line391="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line392="    //% weight=60" line393="    export function digit_createDisplay(clkPin: DigitalPin, dataPin: DigitalPin): void {" line394="        digit_buf = pins.createBuffer(4);" line395="        digit_clkPin = clkPin;" line396="        digit_dataPin = dataPin;" line397="        digit_brightnessLevel = 0;" line398="        digit_pointFlag = false;" line399="        digit_clear();" line400="    }" line401="" line402="    /**" line403="    * Show a 4 digits number on display" line404="    * @param dispData value of number" line405="    */" line406="    //% blockId=hackbit_tm1637_display_number block=&quot;show number|%dispData&quot;" line407="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line408="    //% weight=59" line409="    export function digit_show(dispData: number) {" line410="        let compare_01: number = dispData % 100;" line411="        let compare_001: number = dispData % 1000;" line412="" line413="        if (dispData &lt; 10) {" line414="            digit_bit(dispData, 3);" line415="            digit_bit(0x7f, 2);" line416="            digit_bit(0x7f, 1);" line417="            digit_bit(0x7f, 0);" line418="        }" line419="        else if (dispData &lt; 100) {" line420="            digit_bit(dispData % 10, 3);" line421="            if (dispData &gt; 90) {" line422="                digit_bit(9, 2);" line423="            } else {" line424="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line425="            }" line426="" line427="            digit_bit(0x7f, 1);" line428="            digit_bit(0x7f, 0);" line429="        }" line430="        else if (dispData &lt; 1000) {" line431="            digit_bit(dispData % 10, 3);" line432="            if (compare_01 &gt; 90) {" line433="                digit_bit(9, 2);" line434="            } else {" line435="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line436="            }" line437="            if (compare_001 &gt; 900) {" line438="                digit_bit(9, 1);" line439="            } else {" line440="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line441="            }" line442="            digit_bit(0x7f, 0);" line443="        }" line444="        else if (dispData &lt; 10000) {" line445="            digit_bit(dispData % 10, 3);" line446="            if (compare_01 &gt; 90) {" line447="                digit_bit(9, 2);" line448="            } else {" line449="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line450="            }" line451="            if (compare_001 &gt; 900) {" line452="                digit_bit(9, 1);" line453="            } else {" line454="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line455="            }" line456="            if (dispData &gt; 9000) {" line457="                digit_bit(9, 0);" line458="            } else {" line459="                digit_bit(Math.floor(dispData / 1000) % 10, 0);" line460="            }" line461="        }" line462="        else {" line463="            digit_bit(9, 3);" line464="            digit_bit(9, 2);" line465="            digit_bit(9, 1);" line466="            digit_bit(9, 0);" line467="        }" line468="    }" line469="" line470="    /**" line471="     * Set the brightness level of display at from 0 to 7" line472="     * @param level value of brightness light level" line473="     */" line474="    //% blockId=hackbit_tm1637_set_display_level block=&quot;brightness level to|%level&quot;" line475="    //% level.min=0 level.max=7" line476="    //% weight=58" line477="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;     " line478="    export function digit_set(level: number) {" line479="        digit_brightnessLevel = level;" line480="" line481="        digit_bit(digit_buf[0], 0x00);" line482="        digit_bit(digit_buf[1], 0x01);" line483="        digit_bit(digit_buf[2], 0x02);" line484="        digit_bit(digit_buf[3], 0x03);" line485="    }" line486="" line487="    /**" line488="     * Show a single number from 0 to 9 at a specified digit of Grove - 4-Digit Display" line489="     * @param dispData value of number" line490="     * @param bitAddr value of bit number" line491="     */" line492="    //% blockId=grove_tm1637_display_bit block=&quot;%strip|show single number|%dispData|at digit|%bitAddr&quot;" line493="    //% dispData.min=0 dispData.max=9" line494="    //% bitAddr.min=0 bitAddr.max=3" line495="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line496="    //% advanced=false" line497="    export function digit_bit(dispData: number, bitAddr: number) {" line498="        if ((dispData == 0x7f) || ((dispData &lt;= 9) &amp;&amp; (bitAddr &lt;= 3))) {" line499="            let segData = 0;" line500="" line501="            segData = digit_coding(dispData);" line502="            digit_start();" line503="            digit_writeByte(0x44);" line504="            digit_stop();" line505="            digit_start();" line506="            digit_writeByte(bitAddr | 0xc0);" line507="            digit_writeByte(segData);" line508="            digit_stop();" line509="            digit_start();" line510="            digit_writeByte(0x88 + digit_brightnessLevel);" line511="            digit_stop();" line512="" line513="            digit_buf[bitAddr] = dispData;" line514="        }" line515="    }" line516="" line517="    /**" line518="     * Turn on or off the colon point on Grove - 4-Digit Display" line519="     * @param pointEn value of point switch" line520="     */" line521="    //% blockId=grove_tm1637_display_point block=&quot;%strip|turn|%point|colon point&quot;" line522="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;   " line523="    //% advanced=false" line524="    export function digit_point(point: boolean) {" line525="        digit_pointFlag = point;" line526="" line527="        digit_bit(digit_buf[0], 0x00);" line528="        digit_bit(digit_buf[1], 0x01);" line529="        digit_bit(digit_buf[2], 0x02);" line530="        digit_bit(digit_buf[3], 0x03);" line531="    }" line532="" line533="    /**" line534="     * Clear the display" line535="     */" line536="    //% blockId=grove_tm1637_display_clear block=&quot;%strip|clear&quot;" line537="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line538="    //% advanced=false" line539="    export function digit_clear() {" line540="        digit_bit(0x7f, 0x00);" line541="        digit_bit(0x7f, 0x01);" line542="        digit_bit(0x7f, 0x02);" line543="        digit_bit(0x7f, 0x03);" line544="    }" line545="" line546="    /*" line547="     * Private functions" line548="     */" line549="    function swap16(val: NumberFormat.UInt16BE) {" line550="        return ((val &amp; 0xFF) &lt;&lt; 8)" line551="            | ((val &gt;&gt; 8) &amp; 0xFF);" line552="    }" line553="" line554="    function digit_writeByte(wrData: number) {" line555="        for (let i = 0; i &lt; 8; i++) {" line556="            pins.digitalWritePin(digit_clkPin, 0);" line557="            if (wrData &amp; 0x01) pins.digitalWritePin(digit_dataPin, 1);" line558="            else pins.digitalWritePin(digit_dataPin, 0);" line559="            wrData &gt;&gt;= 1;" line560="            pins.digitalWritePin(digit_clkPin, 1);" line561="        }" line562="" line563="        pins.digitalWritePin(digit_clkPin, 0); // Wait for ACK" line564="        pins.digitalWritePin(digit_dataPin, 1);" line565="        pins.digitalWritePin(digit_clkPin, 1);" line566="    }" line567="" line568="    function digit_start() {" line569="        pins.digitalWritePin(digit_clkPin, 1);" line570="        pins.digitalWritePin(digit_dataPin, 1);" line571="        pins.digitalWritePin(digit_dataPin, 0);" line572="        pins.digitalWritePin(digit_clkPin, 0);" line573="    }" line574="" line575="    function digit_stop() {" line576="        pins.digitalWritePin(digit_clkPin, 0);" line577="        pins.digitalWritePin(digit_dataPin, 0);" line578="        pins.digitalWritePin(digit_clkPin, 1);" line579="        pins.digitalWritePin(digit_dataPin, 1);" line580="    }" line581="" line582="    function digit_coding(dispData: number): number {" line583="        let pointData = 0;" line584="" line585="        if (digit_pointFlag == true) pointData = 0x80;" line586="        else if (digit_pointFlag == false) pointData = 0;" line587="" line588="        if (dispData == 0x7f) dispData = 0x00 + pointData;" line589="        else dispData = TubeTab[dispData] + pointData;" line590="" line591="        return dispData;" line592="    }" line593="" line594="    function paj7620WriteReg(addr: number, cmd: number) {" line595="        let buf: Buffer = pins.createBuffer(2);" line596="" line597="        buf[0] = addr;" line598="        buf[1] = cmd;" line599="" line600="        pins.i2cWriteBuffer(0x73, buf, false);" line601="    }" line602="" line603="    function paj7620ReadReg(addr: number): number {" line604="        let buf2: Buffer = pins.createBuffer(1);" line605="" line606="        buf2[0] = addr;" line607="" line608="        pins.i2cWriteBuffer(0x73, buf2, false);" line609="" line610="        buf2 = pins.i2cReadBuffer(0x73, 1, false);" line611="" line612="        return buf2[0];" line613="    }" line614="" line615="    function paj7620SelectBank(bank: number) {" line616="        if (bank == 0) paj7620WriteReg(0xEF, 0);" line617="        else if (bank == 1) paj7620WriteReg(0xEF, 1);" line618="    }" line619="" line620="    function paj7620Init() {" line621="        let temp = 0;" line622="" line623="        paj7620SelectBank(0);" line624="" line625="        temp = paj7620ReadReg(0);" line626="        if (temp == 0x20) {" line627="            for (let j = 0; j &lt; 438; j += 2) {" line628="                paj7620WriteReg(initRegisterArray[j], initRegisterArray[j + 1]);" line629="            }" line630="        }" line631="" line632="        paj7620SelectBank(0);" line633="    }" line634="   " line635="" line636="}" numlines="637"></mutation></block></statement></block></xml>