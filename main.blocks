<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="FRHB|;t,WFke9;]{D|!%" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="N*2a=/dO-m4}sl45O*Z(" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace hackbit {" line1="// /**" line2="//  * Library for hackbit,  grove micro:bit project board https://www.hackids.com.br" line3="// */" line4="// //% weight=10 color=#FF1344 icon=&quot;\uf0eb&quot;    " line5="    let gesture_first_init = true" line6="    const initRegisterArray: number[] = [" line7="        0xEF, 0x00, 0x32, 0x29, 0x33, 0x01, 0x34, 0x00, 0x35, 0x01, 0x36, 0x00, 0x37, 0x07, 0x38, 0x17," line8="        0x39, 0x06, 0x3A, 0x12, 0x3F, 0x00, 0x40, 0x02, 0x41, 0xFF, 0x42, 0x01, 0x46, 0x2D, 0x47, 0x0F," line9="        0x48, 0x3C, 0x49, 0x00, 0x4A, 0x1E, 0x4B, 0x00, 0x4C, 0x20, 0x4D, 0x00, 0x4E, 0x1A, 0x4F, 0x14," line10="        0x50, 0x00, 0x51, 0x10, 0x52, 0x00, 0x5C, 0x02, 0x5D, 0x00, 0x5E, 0x10, 0x5F, 0x3F, 0x60, 0x27," line11="        0x61, 0x28, 0x62, 0x00, 0x63, 0x03, 0x64, 0xF7, 0x65, 0x03, 0x66, 0xD9, 0x67, 0x03, 0x68, 0x01," line12="        0x69, 0xC8, 0x6A, 0x40, 0x6D, 0x04, 0x6E, 0x00, 0x6F, 0x00, 0x70, 0x80, 0x71, 0x00, 0x72, 0x00," line13="        0x73, 0x00, 0x74, 0xF0, 0x75, 0x00, 0x80, 0x42, 0x81, 0x44, 0x82, 0x04, 0x83, 0x20, 0x84, 0x20," line14="        0x85, 0x00, 0x86, 0x10, 0x87, 0x00, 0x88, 0x05, 0x89, 0x18, 0x8A, 0x10, 0x8B, 0x01, 0x8C, 0x37," line15="        0x8D, 0x00, 0x8E, 0xF0, 0x8F, 0x81, 0x90, 0x06, 0x91, 0x06, 0x92, 0x1E, 0x93, 0x0D, 0x94, 0x0A," line16="        0x95, 0x0A, 0x96, 0x0C, 0x97, 0x05, 0x98, 0x0A, 0x99, 0x41, 0x9A, 0x14, 0x9B, 0x0A, 0x9C, 0x3F," line17="        0x9D, 0x33, 0x9E, 0xAE, 0x9F, 0xF9, 0xA0, 0x48, 0xA1, 0x13, 0xA2, 0x10, 0xA3, 0x08, 0xA4, 0x30," line18="        0xA5, 0x19, 0xA6, 0x10, 0xA7, 0x08, 0xA8, 0x24, 0xA9, 0x04, 0xAA, 0x1E, 0xAB, 0x1E, 0xCC, 0x19," line19="        0xCD, 0x0B, 0xCE, 0x13, 0xCF, 0x64, 0xD0, 0x21, 0xD1, 0x0F, 0xD2, 0x88, 0xE0, 0x01, 0xE1, 0x04," line20="        0xE2, 0x41, 0xE3, 0xD6, 0xE4, 0x00, 0xE5, 0x0C, 0xE6, 0x0A, 0xE7, 0x00, 0xE8, 0x00, 0xE9, 0x00," line21="        0xEE, 0x07, 0xEF, 0x01, 0x00, 0x1E, 0x01, 0x1E, 0x02, 0x0F, 0x03, 0x10, 0x04, 0x02, 0x05, 0x00," line22="        0x06, 0xB0, 0x07, 0x04, 0x08, 0x0D, 0x09, 0x0E, 0x0A, 0x9C, 0x0B, 0x04, 0x0C, 0x05, 0x0D, 0x0F," line23="        0x0E, 0x02, 0x0F, 0x12, 0x10, 0x02, 0x11, 0x02, 0x12, 0x00, 0x13, 0x01, 0x14, 0x05, 0x15, 0x07," line24="        0x16, 0x05, 0x17, 0x07, 0x18, 0x01, 0x19, 0x04, 0x1A, 0x05, 0x1B, 0x0C, 0x1C, 0x2A, 0x1D, 0x01," line25="        0x1E, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x25, 0x01, 0x26, 0x00, 0x27, 0x39, 0x28, 0x7F," line26="        0x29, 0x08, 0x30, 0x03, 0x31, 0x00, 0x32, 0x1A, 0x33, 0x1A, 0x34, 0x07, 0x35, 0x07, 0x36, 0x01," line27="        0x37, 0xFF, 0x38, 0x36, 0x39, 0x07, 0x3A, 0x00, 0x3E, 0xFF, 0x3F, 0x00, 0x40, 0x77, 0x41, 0x40," line28="        0x42, 0x00, 0x43, 0x30, 0x44, 0xA0, 0x45, 0x5C, 0x46, 0x00, 0x47, 0x00, 0x48, 0x58, 0x4A, 0x1E," line29="        0x4B, 0x1E, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0xA0, 0x4F, 0x80, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00," line30="        0x53, 0x00, 0x54, 0x00, 0x57, 0x80, 0x59, 0x10, 0x5A, 0x08, 0x5B, 0x94, 0x5C, 0xE8, 0x5D, 0x08," line31="        0x5E, 0x3D, 0x5F, 0x99, 0x60, 0x45, 0x61, 0x40, 0x63, 0x2D, 0x64, 0x02, 0x65, 0x96, 0x66, 0x00," line32="        0x67, 0x97, 0x68, 0x01, 0x69, 0xCD, 0x6A, 0x01, 0x6B, 0xB0, 0x6C, 0x04, 0x6D, 0x2C, 0x6E, 0x01," line33="        0x6F, 0x32, 0x71, 0x00, 0x72, 0x01, 0x73, 0x35, 0x74, 0x00, 0x75, 0x33, 0x76, 0x31, 0x77, 0x01," line34="        0x7C, 0x84, 0x7D, 0x03, 0x7E, 0x01" line35="    ];" line36="    /////////////////////////color/////////////////////////" line37="    const APDS9960_ADDR = 0x39" line38="    const APDS9960_ENABLE = 0x80" line39="    const APDS9960_ATIME = 0x81" line40="    const APDS9960_CONTROL = 0x8F" line41="    const APDS9960_STATUS = 0x93" line42="    const APDS9960_CDATAL = 0x94" line43="    const APDS9960_CDATAH = 0x95" line44="    const APDS9960_RDATAL = 0x96" line45="    const APDS9960_RDATAH = 0x97" line46="    const APDS9960_GDATAL = 0x98" line47="    const APDS9960_GDATAH = 0x99" line48="    const APDS9960_BDATAL = 0x9A" line49="    const APDS9960_BDATAH = 0x9B" line50="    const APDS9960_GCONF4 = 0xAB" line51="    const APDS9960_AICLEAR = 0xE7    " line52="    let color_first_init = false" line53="" line54="    export enum OnOff {" line55="        //% block=&quot;On&quot;" line56="        On = 1," line57="        //% block=&quot;Off&quot;" line58="        Off = 0" line59="    }" line60="" line61="    export enum Color {" line62="        //% block=&quot;Red&quot;" line63="        Red," line64="        //% block=&quot;Green&quot;" line65="        Green," line66="        //% block=&quot;Blue&quot;" line67="        Blue," line68="        //% block=&quot;Clear&quot;" line69="        Clear" line70="    }" line71="" line72="    export enum ColorList {" line73="        //% block=&quot;Red&quot;" line74="        red," line75="        //% block=&quot;Green&quot;" line76="        green," line77="        //% block=&quot;Blue&quot;" line78="        blue," line79="        //% block=&quot;Cyan&quot;" line80="        cyan," line81="        //% block=&quot;Magenta&quot;" line82="        magenta," line83="        //% block=&quot;Yellow&quot;" line84="        yellow," line85="        //% block=&quot;White&quot;" line86="        white" line87="    }" line88="" line89="    export enum GroveGesture {" line90="        //% block=None" line91="        None = 0," line92="        //% block=Right" line93="        Right = 1," line94="        //% block=Left" line95="        Left = 2," line96="        //% block=Up" line97="        Up = 3," line98="        //% block=Down" line99="        Down = 4," line100="        //% block=Forward" line101="        Forward = 5," line102="        //% block=Backward" line103="        Backward = 6," line104="        //% block=Clockwise" line105="        Clockwise = 7," line106="        //% block=Anticlockwise" line107="        Anticlockwise = 8," line108="        //% block=Wave" line109="        Wave = 9" line110="    }" line111="" line112="    export enum DHT11_state {" line113="        //% block=&quot;temperature(℃)&quot; enumval=0" line114="        DHT11_temperature_C," line115="" line116="        //% block=&quot;humidity(0~100)&quot; enumval=1" line117="        DHT11_humidity," line118="    }" line119="" line120="    export enum GasList {" line121="        //% block=&quot;Co&quot;" line122="        Co," line123="        //% block=&quot;Co2&quot;" line124="        Co2," line125="        //% block=&quot;Smoke&quot;" line126="        Smoke," line127="        //% block=&quot;Alcohol&quot;" line128="        Alcohol" line129="    }" line130="    " line131="&#9;export enum GroveJoystickKey {" line132="&#9;&#9;//% block=&quot;none&quot;" line133="&#9;&#9;None = 0," line134="&#9;&#9;//%block=&quot;Right&quot;" line135="&#9;&#9;Right = 1," line136="&#9;&#9;//% block=&quot;Left&quot;" line137="&#9;&#9;Left = 2," line138="&#9;&#9;//% block=&quot;Up&quot;" line139="&#9;&#9;Up = 3," line140="&#9;&#9;//% block=&quot;Down&quot;" line141="&#9;&#9;Down = 4," line142="&#9;&#9;//% block=&quot;Upper left&quot;" line143="&#9;&#9;UL = 5," line144="&#9;&#9;//% block=&quot;Upper right&quot;" line145="&#9;&#9;UR = 6," line146="&#9;&#9;//% block=&quot;Lower left&quot;" line147="&#9;&#9;LL = 7," line148="&#9;&#9;//% block=&quot;Lower right&quot;" line149="&#9;&#9;LR = 8," line150="&#9;&#9;//% block=&quot;press&quot;" line151="&#9;&#9;Press = 9" line152="&#9;}" line153="" line154="    export let identifiant = 0;" line155="    export let grovegestureinit = 0;" line156="" line157="    let TubeTab: number[] = [" line158="        0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07," line159="        0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71" line160="    ];" line161="" line162="    export let digit_clkPin: DigitalPin;" line163="    export let digit_dataPin: DigitalPin;" line164="    export let digit_brightnessLevel: number;" line165="    export let digit_pointFlag: boolean;" line166="    export let digit_buf: Buffer;" line167="" line168="    /**" line169="     * Set relay state" line170="    */" line171="    //% blockId=hackbitRelay" line172="    //% block=&quot;relay pin |%pin| state |%RelayState|&quot;" line173="    //% pin.fieldEditor=&quot;gridpicker&quot;" line174="    //% pin.fieldOptions.columns=2" line175="    //% RelayState.fieldEditor=&quot;gridpicker&quot;" line176="    //% RelayState.fieldOptions.columns=1" line177="    //% RelayState.min=0 state.max=1" line178="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line179="    export function hackbitRelayState(pin: DigitalPin, RelayState: OnOff): void {" line180="        switch (RelayState) {" line181="            case 0:" line182="                pins.digitalWritePin(pin, 0)" line183="                break;" line184="            case 1:" line185="                pins.digitalWritePin(pin, 1)" line186="                break;" line187="        }" line188="    }" line189="" line190="    /**" line191="     * Set vibration motor state" line192="    */" line193="    //% blockId=hackbitVibrationMotor" line194="    //% block=&quot;vibration motor pin |%pin| state |%VibrationMotorState|&quot;" line195="    //% pin.fieldEditor=&quot;gridpicker&quot;" line196="    //% pin.fieldOptions.columns=2" line197="    //% VibrationMotor.fieldEditor=&quot;gridpicker&quot;" line198="    //% VibrationMotor.fieldOptions.columns=1" line199="    //% VibrationMotor.min=0 state.max=1" line200="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line201="    export function hackbitVibrationMotorState(pin: DigitalPin, VibrationMotorState: OnOff): void {" line202="        switch (VibrationMotorState) {" line203="            case 0:" line204="                pins.digitalWritePin(pin, 0)" line205="                break;" line206="            case 1:" line207="                pins.digitalWritePin(pin, 1)" line208="                break;" line209="        }" line210="    }" line211="" line212="    /**" line213="     * Set mini fan state" line214="    */" line215="    //% blockId=hackbitMiniFan" line216="    //% block=&quot;mini fan pin |%pin| state |%MiniFanState|&quot;" line217="    //% pin.fieldEditor=&quot;gridpicker&quot;" line218="    //% pin.fieldOptions.columns=2" line219="    //% MiniFanState.fieldEditor=&quot;gridpicker&quot;" line220="    //% MiniFanState.fieldOptions.columns=1" line221="    //% MiniFanState.min=0 state.max=1" line222="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line223="    export function hackbitMiniFanState(pin: DigitalPin, MiniFanState: OnOff): void {" line224="        switch (MiniFanState) {" line225="            case 0:" line226="                pins.digitalWritePin(pin, 0)" line227="                break;" line228="            case 1:" line229="                pins.digitalWritePin(pin, 1)" line230="                break;" line231="        }" line232="    }" line233="" line234="    /**" line235="     * Set laser state" line236="    */" line237="    //% blockId=hackbitLaser" line238="    //% block=&quot;laser pin |%pin| state |%LaserState|&quot;" line239="    //% pin.fieldEditor=&quot;gridpicker&quot;" line240="    //% pin.fieldOptions.columns=2" line241="    //% LaserState.fieldEditor=&quot;gridpicker&quot;" line242="    //% LaserState.fieldOptions.columns=1" line243="    //% LaserState.min=0 state.max=1" line244="    //% subcategory=Actuators  group=&quot;Digital&quot; color=#E52297 icon=&quot;\uf1eb&quot;    " line245="    export function hackbitLaserState(pin: DigitalPin, LaserState: OnOff): void {" line246="        switch (LaserState) {" line247="            case 0:" line248="                pins.digitalWritePin(pin, 0)" line249="                break;" line250="            case 1:" line251="                pins.digitalWritePin(pin, 1)" line252="                break;" line253="        }" line254="    }" line255="" line256="" line257="    /**" line258="     * get distance from ultrasonic range sensor [cm]" line259="     * @param pin Input pin" line260="     */" line261="    //% blockId=RobotDriverultrasonic_cm " line262="    //% block=&quot;ultrasonic ranger pin |%name| distance(cm)&quot;" line263="    //% name.fieldEditor=&quot;gridpicker&quot; " line264="    //% name.fieldOptions.columns=5" line265="    //% name.fieldOptions.tooltips=&quot;false&quot;" line266="    //% name.fieldOptions.width=&quot;0&quot;" line267="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;" line268="    export function measureDistanceCentimeter(name: DigitalPin): number {" line269="        let duration = 0;" line270="        let distance = 0;" line271="        pins.digitalWritePin(name, 0); //make sure pin is low" line272="        control.waitMicros(2);" line273="        pins.digitalWritePin(name, 1); //send echo" line274="        control.waitMicros(20);" line275="        pins.digitalWritePin(name, 0);" line276="        duration = pins.pulseIn(name, PulseValue.High, 50000); // Max duration 50 ms - receive echo" line277="        distance = duration * 153 / 29 / 2 / 100;" line278="        Math.constrain(distance, 0, 500);" line279="        return distance;" line280="    }" line281="" line282="    /**" line283="     * Get line finder sensor state [0-1]" line284="    */" line285="    //% blockId=hackbitLineFinderRead" line286="    //% block=&quot;pin |%pin| line finder is seeing black&quot;" line287="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line288="    export function detectline(pin: DigitalPin): boolean {" line289="        pins.setPull(pin, PinPullMode.PullUp)" line290="        if (pins.digitalReadPin(pin) == 0) {" line291="            return true" line292="        }" line293="        else {" line294="            return false" line295="        }" line296="    }" line297="" line298="    /**" line299="     * Get collision sensor state [0-1]" line300="    */" line301="    //% blockId=hackbitCollisionRead" line302="    //% block=&quot;collision sensor pin |%pin| activated&quot;" line303="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line304="    export function collisionSensor(pin: DigitalPin): boolean {" line305="        pins.setPull(pin, PinPullMode.PullUp)" line306="        if (pins.digitalReadPin(pin) == 0) {" line307="            return true" line308="        }" line309="        else {" line310="            return false" line311="        }" line312="    }" line313="" line314="    /**" line315="     * Get PIR sensor state [0-1]" line316="    */" line317="    //% blockId=hackbitPIRRead" line318="    //% block=&quot;PIR sensor pin |%pin| detects motion&quot;" line319="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line320="    export function PIRState(pin: DigitalPin): boolean {" line321="        pins.setPull(pin, PinPullMode.PullUp)" line322="        if (pins.digitalReadPin(pin) == 0) {" line323="            return true" line324="        }" line325="        else {" line326="            return false" line327="        }" line328="    }" line329="" line330="    /**" line331="     * Get water sensor state [0-1]" line332="    */" line333="    //% blockId=hackbitWaterRead" line334="    //% block=&quot;water sensor pin |%pin| detects water&quot;" line335="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line336="    export function WaterState(pin: DigitalPin): boolean {" line337="        pins.setPull(pin, PinPullMode.PullUp)" line338="        if (pins.digitalReadPin(pin) == 0) {" line339="            return true" line340="        }" line341="        else {" line342="            return false" line343="        }" line344="    }" line345="" line346="    /**" line347="     * Get Magnetic Switch state [0-1]" line348="    */" line349="    //% blockId=hackbitMagneticSwitchRead" line350="    //% block=&quot;magnetic switch pin |%pin| activated&quot;" line351="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line352="    export function MagneticSwitchState(pin: DigitalPin): boolean {" line353="        pins.setPull(pin, PinPullMode.PullUp)" line354="        if (pins.digitalReadPin(pin) == 0) {" line355="            return true" line356="        }" line357="        else {" line358="            return false" line359="        }" line360="    }" line361="" line362="    /**" line363="     * Get hall sensor state [0-1]" line364="    */" line365="    //% blockId=hackbitHallRead" line366="    //% block=&quot;hall sensor pin |%pin| activated&quot;" line367="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line368="    export function HallState(pin: DigitalPin): boolean {" line369="        pins.setPull(pin, PinPullMode.PullUp)" line370="        if (pins.digitalReadPin(pin) == 0) {" line371="            return true" line372="        }" line373="        else {" line374="            return false" line375="        }" line376="    }" line377="" line378="    /**" line379="     * Get crash button state [0-1]" line380="    */" line381="    //% blockId=hackbitCrashRead" line382="    //% block=&quot;crash sensor |%pin| is pressed&quot;" line383="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;    " line384="    export function CrashButton(pin: DigitalPin): boolean {" line385="        pins.setPull(pin, PinPullMode.PullUp)" line386="        if (pins.digitalReadPin(pin) == 0) {" line387="            return true" line388="        }" line389="        else {" line390="            return false" line391="        }" line392="    }        " line393="" line394="    /**" line395="     * Get flame sensor state [0-1]" line396="    */" line397="    //% blockId=hackbitFlameRead" line398="    //% block=&quot;flame sensor pin |%pin| detects flame&quot;" line399="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line400="    export function FlameState(pin: DigitalPin): boolean {" line401="        pins.setPull(pin, PinPullMode.PullUp)" line402="        if (pins.digitalReadPin(pin) == 0) {" line403="            return true" line404="        }" line405="        else {" line406="            return false" line407="        }" line408="    }" line409="" line410="    /**" line411="     * Get touch sensor state [0-1]" line412="    */" line413="    //% blockId=hackbitTouchRead" line414="    //% block=&quot;touch sensor pin |%pin| touched&quot;" line415="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;        " line416="    export function TouchState(pin: DigitalPin): boolean {" line417="        pins.setPull(pin, PinPullMode.PullUp)" line418="        if (pins.digitalReadPin(pin) == 0) {" line419="            return true" line420="        }" line421="        else {" line422="            return false" line423="        }" line424="    }" line425="" line426="    /**" line427="     * Get vibration state [0-1]" line428="    */" line429="    //% blockId=hackbitVibrationRead" line430="    //% block=&quot;vibration sensor pin |%pin| detects vibration&quot;" line431="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#1371FF icon=&quot;\uf1eb&quot;    " line432="    export function VibrationRead(pin: DigitalPin): boolean {" line433="        pins.setPull(pin, PinPullMode.PullUp)" line434="        if (pins.digitalReadPin(pin) == 0) {" line435="            return true" line436="        }" line437="        else {" line438="            return false" line439="        }" line440="    }        " line441="" line442="    /**" line443="     * Get button state [0-1]" line444="    */" line445="    //% blockId=hackbitButtonRead" line446="    //% block=&quot;button pin |%pin| is pressed&quot;" line447="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line448="    export function buttonState(pin: DigitalPin): boolean {" line449="        pins.setPull(pin, PinPullMode.PullUp)" line450="        if (pins.digitalReadPin(pin) == 0) {" line451="            return true" line452="        }" line453="        else {" line454="            return false" line455="        }" line456="    }" line457="" line458="    /**" line459="     * Get button LED state [0-1]" line460="    */" line461="    //% blockId=hackbitButtonLEDRead" line462="    //% block=&quot;button pin LED |%pin| is pressed&quot;" line463="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line464="    export function buttonLEDState(pin: DigitalPin): boolean {" line465="        pins.setPull(pin, PinPullMode.PullUp)" line466="        if (pins.digitalReadPin(pin) == 0) {" line467="            return true" line468="        }" line469="        else {" line470="            return false" line471="        }" line472="    }" line473="" line474="    /**" line475="     * Get Tilt state [0-1]" line476="    */" line477="    //% blockId=hackbitTiltRead" line478="    //% block=&quot;tilt switch pin |%pin| tilted&quot;" line479="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line480="    export function TiltState(pin: DigitalPin): boolean {" line481="        pins.setPull(pin, PinPullMode.PullUp)" line482="        if (pins.digitalReadPin(pin) == 0) {" line483="            return true" line484="        }" line485="        else {" line486="            return false" line487="        }" line488="    }" line489="" line490="    /**" line491="     * Get Switch (P) state [0-1]" line492="    */" line493="    //% blockId=hackbitSwitchRead" line494="    //% block=&quot;switch(P) pin |%pin| activated&quot;" line495="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#851DE8 icon=&quot;\uf1eb&quot;    " line496="    export function SwitchState(pin: DigitalPin): boolean {" line497="        pins.setPull(pin, PinPullMode.PullUp)" line498="        if (pins.digitalReadPin(pin) == 0) {" line499="            return true" line500="        }" line501="        else {" line502="            return false" line503="        }" line504="    }" line505="" line506="    /**" line507="    * Get soil moisture(0~100%)" line508="    * @param soilmoisturepin describe parameter here, eg: AnalogPin.P1" line509="    */" line510="    //% blockId=&quot;hackbitSoilMoistureRead&quot; block=&quot;value of soil moisture(0~100) at pin %soilhumiditypin&quot;" line511="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line512="    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {" line513="        let voltage = 0;" line514="        let soilmoisture = 0;" line515="        voltage = pins.map(" line516="            pins.analogReadPin(soilmoisturepin)," line517="            0," line518="            1023," line519="            0," line520="            100" line521="        );" line522="        soilmoisture = voltage;" line523="        return Math.round(soilmoisture);" line524="    }" line525="" line526="    /**" line527="    * Get light intensity(0~100%)" line528="    * @param lightintensitypin describe parameter here, eg: AnalogPin.P1" line529="    */" line530="    //% blockId=&quot;hackbitLightIntensityRead&quot; block=&quot;value of light intensity(0~100) at pin %lightintensitypin&quot;" line531="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line532="    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {" line533="        let voltage2 = 0;" line534="        let lightintensity = 0;" line535="        voltage2 = pins.map(" line536="            pins.analogReadPin(lightintensitypin)," line537="            0," line538="            1023," line539="            0," line540="            100" line541="        );" line542="        lightintensity = voltage2;" line543="        return Math.round(lightintensity);" line544="    }" line545="" line546="    /**" line547="    * Get UV level value (0~15)" line548="    * @param uvlevelpin describe parameter here, eg: AnalogPin.P1" line549="    */" line550="    //% blockId=&quot;hackbitUVLevelRead&quot; block=&quot;UV sensor (0~15) at pin %uvlevelpin&quot;" line551="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line552="    export function UVLevel(uvlevelpin: AnalogPin): number {" line553="        let UVlevel = pins.analogReadPin(uvlevelpin);" line554="        if (UVlevel &gt; 625) {" line555="            UVlevel = 625" line556="        }" line557="        UVlevel = pins.map(" line558="            UVlevel," line559="            0," line560="            625," line561="            0," line562="            15" line563="        );" line564="        return Math.round(UVlevel)" line565="    }" line566="" line567="    /**" line568="    * Get dht11 temperature and humidity Value" line569="    * @param dht11pin describe parameter here, eg: DigitalPin.P15     " line570="    */" line571="    //% blockId=&quot;hackbitDHT11Read&quot; block=&quot;DHT11 sensor %DHT11pin %dht11state value&quot;" line572="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line573="    export function dht11Sensor(DHT11pin: DigitalPin, dht11state: DHT11_state): number {" line574="        basic.pause(1000)  //There must be more than 2000ms between two requests" line575="        pins.digitalWritePin(DHT11pin, 0)" line576="        basic.pause(18)" line577="        let i = pins.digitalReadPin(DHT11pin)" line578="        pins.setPull(DHT11pin, PinPullMode.PullUp);" line579="        switch (dht11state) {" line580="            case 0:" line581="                let dhtvalue1 = 0;" line582="                let dhtcounter1 = 0;" line583="                while (pins.digitalReadPin(DHT11pin) == 1);" line584="                while (pins.digitalReadPin(DHT11pin) == 0);" line585="                while (pins.digitalReadPin(DHT11pin) == 1);" line586="                for (let j = 0; j &lt;= 32 - 1; j++) {" line587="                    while (pins.digitalReadPin(DHT11pin) == 0);" line588="                    dhtcounter1 = 0" line589="                    while (pins.digitalReadPin(DHT11pin) == 1) {" line590="                        dhtcounter1 += 1;" line591="                    }" line592="                    if (j &gt; 15) {" line593="                        if (dhtcounter1 &gt; 2) {" line594="                            dhtvalue1 = dhtvalue1 + (1 &lt;&lt; (31 - j));" line595="                        }" line596="                    }" line597="                }" line598="                return ((dhtvalue1 &amp; 0x0000ff00) &gt;&gt; 8);" line599="                break;" line600="            case 1:" line601="                while (pins.digitalReadPin(DHT11pin) == 1);" line602="                while (pins.digitalReadPin(DHT11pin) == 0);" line603="                while (pins.digitalReadPin(DHT11pin) == 1);" line604="" line605="                let value = 0;" line606="                let counter = 0;" line607="" line608="                for (let k = 0; k &lt;= 8 - 1; k++) {" line609="                    while (pins.digitalReadPin(DHT11pin) == 0);" line610="                    counter = 0" line611="                    while (pins.digitalReadPin(DHT11pin) == 1) {" line612="                        counter += 1;" line613="                    }" line614="                    if (counter &gt; 3) {" line615="                        value = value + (1 &lt;&lt; (7 - k));" line616="                    }" line617="                }" line618="                return value;" line619="            default:" line620="                return 0;" line621="        }" line622="    }" line623="" line624="    /** " line625="    * Get temperature value Celsius" line626="    * @param temperaturepin describe parameter here, eg: AnalogPin.P1" line627="    */" line628="    //% blockId=&quot;hackbitTemperatureRead&quot; block=&quot;value of temperature (Celsius) at pin %temperaturepin&quot;" line629="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line630="    export function ReadTemperature(temperaturepin: AnalogPin): number {" line631="        let A               // value " line632="        let B = 4275        // B value of the thermistor" line633="        let R = 0" line634="        let R0 = 100000     // R0 = 100k" line635="        let temp = 0" line636="        A = pins.analogReadPin(temperaturepin)" line637="        R = 1023.0/A-1.0" line638="        R = R0*R;" line639="        temp = 1.0/(Math.log(R/R0)/B+1/298.15)-273.15 // convert to temperature via datasheet" line640="        return Math.round(temp)" line641="    }" line642="" line643="    /** " line644="    * Get Gas Sensor concentration value " line645="    */" line646="    //% blockId=&quot;hackbitGasRead&quot; block=&quot;%sensor gas sensor at pin %gaspin concentration value&quot;" line647="    //% gaspin.fieldEditor=&quot;gridpicker&quot; gaspin.fieldOptions.columns=2" line648="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=2    " line649="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line650="    export function hackbitGasRead(sensor: GasList, gaspin: AnalogPin): number {" line651="        if(sensor==GasList.Co2){" line652="            return 1024-pins.analogReadPin(gaspin)" line653="        }" line654="        return pins.analogReadPin(gaspin)" line655="    }" line656="" line657="    /** " line658="    * Get noise(dB)" line659="    * @param noisepin describe parameter here, eg: AnalogPin.P1, (Loudness Sensor)" line660="    */" line661="    //% blockId=&quot;hackbitNoiseRead&quot; block=&quot;value of noise(dB) at pin %noisepin&quot;" line662="    //% subcategory=Sensor  group=&quot;Analog&quot; color=#00D828 icon=&quot;\uf1eb&quot;    " line663="    export function ReadNoise(noisepin: AnalogPin): number {" line664="        let level = 0" line665="        let voltage3 = 0" line666="        let noise = 0" line667="        let h = 0" line668="        let l = 0" line669="        let sumh = 0" line670="        let suml = 0" line671="        pins.digitalWritePin(DigitalPin.P0, 0)" line672="        for (let m = 0; m &lt; 1000; m++) {" line673="            level = level + pins.analogReadPin(noisepin)" line674="        }" line675="        level = level / 1000" line676="        for (let n = 0; n &lt; 1000; n++) {" line677="            voltage3 = pins.analogReadPin(noisepin)" line678="            if (voltage3 &gt;= level) {" line679="                h += 1" line680="                sumh = sumh + voltage3" line681="            } else {" line682="                l += 1" line683="                suml = suml + voltage3" line684="            }" line685="        }" line686="        if (h == 0) {" line687="            sumh = level" line688="        } else {" line689="            sumh = sumh / h" line690="        }" line691="        if (l == 0) {" line692="            suml = level" line693="        } else {" line694="            suml = suml / l" line695="        }" line696="        noise = sumh - suml" line697="        if (noise &lt;= 4) {" line698="            noise = pins.map(" line699="                noise," line700="                0," line701="                4," line702="                30," line703="                50" line704="            )" line705="        } else if (noise &lt;= 8) {" line706="            noise = pins.map(" line707="                noise," line708="                4," line709="                8," line710="                50," line711="                55" line712="            )" line713="        } else if (noise &lt;= 14) {" line714="            noise = pins.map(" line715="                noise," line716="                9," line717="                14," line718="                55," line719="                60" line720="            )" line721="        } else if (noise &lt;= 32) {" line722="            noise = pins.map(" line723="                noise," line724="                15," line725="                32," line726="                60," line727="                70" line728="            )" line729="        } else if (noise &lt;= 60) {" line730="            noise = pins.map(" line731="                noise," line732="                33," line733="                60," line734="                70," line735="                75" line736="            )" line737="        } else if (noise &lt;= 100) {" line738="            noise = pins.map(" line739="                noise," line740="                61," line741="                100," line742="                75," line743="                80" line744="            )" line745="        } else if (noise &lt;= 150) {" line746="            noise = pins.map(" line747="                noise," line748="                101," line749="                150," line750="                80," line751="                85" line752="            )" line753="        } else if (noise &lt;= 231) {" line754="            noise = pins.map(" line755="                noise," line756="                151," line757="                231," line758="                85," line759="                90" line760="            )" line761="        } else {" line762="            noise = pins.map(" line763="                noise," line764="                231," line765="                1023," line766="                90," line767="                120" line768="            )" line769="        }" line770="        noise = Math.round(noise)" line771="        return Math.round(noise)" line772="    }" line773="" line774="    export class GroveJoystick" line775="    {" line776="        /**" line777="         * Detect position from Grove - Thumb Joystick" line778="         * @param xPin" line779="         * @param yPin" line780="         */" line781="     " line782="        joyread(xPin: AnalogPin, yPin: AnalogPin): number {" line783="" line784="            let xdata = 0, ydata = 0, result = 0;" line785="            if (xPin &amp;&amp; yPin) {" line786="                xdata = pins.analogReadPin(xPin);" line787="                ydata = pins.analogReadPin(yPin);" line788="                if (xdata &gt; 1000) {" line789="                    result = GroveJoystickKey.Press;" line790="                }" line791="                else if (xdata &gt; 600) {" line792="                    if (ydata &gt; 600) result = GroveJoystickKey.UR;" line793="                    else if (ydata &lt; 400) result = GroveJoystickKey.LR;" line794="                    else result = GroveJoystickKey.Right;" line795="                }" line796="                else if (xdata &lt; 400) {" line797="                    if (ydata &gt; 600) result = GroveJoystickKey.UL;" line798="                    else if (ydata &lt; 400) result = GroveJoystickKey.LL;" line799="                    else result = GroveJoystickKey.Left;" line800="                }" line801="                else {" line802="                    if (ydata &gt; 600) result = GroveJoystickKey.Up;" line803="                    else if (ydata &lt; 400) result = GroveJoystickKey.Down;" line804="                    else result = GroveJoystickKey.None;" line805="                }" line806="            }" line807="            else {" line808="                result =  GroveJoystickKey.None;" line809="            }" line810="            return result;" line811="        }" line812="    }" line813="    " line814="    const joystickEventID = 3101;" line815="    let lastJoystick = GroveJoystickKey.None;" line816="    let joystick = new GroveJoystick();" line817="    /**" line818="     * get Joystick key" line819="     * " line820="     */" line821="    //% blockId=grove_getjoystick block=&quot;get joystick key at|%xpin|and|%ypin&quot;" line822="    //% xpin.fieldEditor=&quot;gridpicker&quot;" line823="    //% xpin.fieldOptions.columns=3" line824="    //% ypin.fieldEditor=&quot;gridpicker&quot;" line825="    //% ypin.fieldOptions.columns=3" line826="    //% group=&quot;Thumb Joystick&quot; xpin.defl=AnalogPin.C16 ypin.defl=AnalogPin.C17" line827="    //% subcategory=Input  color=#851DE8 " line828="    export function getJoystick(xpin: AnalogPin, ypin: AnalogPin): number {" line829="        return joystick.joyread(xpin, ypin);" line830="    }" line831="" line832="    /**" line833="     * Converts the key name to a number" line834="     * Useful for comparisons" line835="     */" line836="    //% blockId=joystickkey block=&quot;%key&quot;" line837="    //% key.fieldEditor=&quot;gridpicker&quot;" line838="    //% key.fieldOptions.columns=2" line839="    //% group=&quot;Thumb Joystick&quot;" line840="    //% subcategory=Input  color=#851DE8 " line841="" line842="    export function joystickkey(key: GroveJoystickKey): number {" line843="        return key;" line844="    }" line845="" line846="    /**" line847="     * Do something when a key is detected by Grove - Thumb Joystick" line848="     * @param key type of joystick to detect" line849="     * @param xpin" line850="     * @param ypin" line851="     * @param handler code to run" line852="     */" line853="    //% blockId=grove_joystick_create_event block=&quot;on key|%key at |%xpin|and|%ypin&quot;" line854="    //% key.fieldEditor=&quot;gridpicker&quot;" line855="    //% key.fieldOptions.columns=2" line856="    //% xpin.fieldEditor=&quot;gridpicker&quot;" line857="    //% xpin.fieldOptions.columns=3" line858="    //% ypin.fieldEditor=&quot;gridpicker&quot;" line859="    //% ypin.fieldOptions.columns=3" line860="    //% group=&quot;Thumb Joystick&quot; xpin.defl=AnalogPin.C16 ypin.defl=AnalogPin.C17" line861="    //% subcategory=Input  color=#851DE8 " line862="" line863="    export function onJoystick(key: GroveJoystickKey, xpin: AnalogPin, ypin: AnalogPin, handler: () =&gt; void) {" line864="        control.onEvent(joystickEventID, key, handler);" line865="        control.inBackground(() =&gt; {" line866="            while(true) {" line867="                const key = joystick.joyread(xpin, ypin);" line868="                if (key != lastJoystick) {" line869="                    lastJoystick = key; " line870="                    control.raiseEvent(joystickEventID, lastJoystick);" line871="                }" line872="                basic.pause(50);" line873="            }" line874="        })" line875="        " line876="    }" line877="" line878="    /**" line879="     * Get analog potentiometer value [0-1023]" line880="    */" line881="    //% blockId=hackbitPotargRead" line882="    //% block=&quot;potentiometer pin |%pin| value&quot;" line883="    //% subcategory=Input  group=&quot;Analog&quot; color=#851DE8 icon=&quot;\uf1eb&quot;" line884="    export function potarValue(pin: AnalogPin): number {" line885="        return pins.analogReadPin(pin);" line886="    }" line887="" line888="    /**" line889="     * Get rotary angle sensor [0-300]" line890="    */" line891="    //% blockId=hackbitRotaryRead" line892="    //% block=&quot;rotary angle sensor pin |%pin| value&quot;" line893="    //% subcategory=Input  group=&quot;Analog&quot; color=#851DE8 icon=&quot;\uf1eb&quot;" line894="    export function rotaryValue(pin: AnalogPin): number {" line895="        let tRotaryAngle = pins.analogReadPin(pin)" line896="        let RotaryAngle" line897="        RotaryAngle = pins.map(" line898="            tRotaryAngle," line899="            0," line900="            1023," line901="            0," line902="            300" line903="        );" line904="        return Math.round(RotaryAngle)" line905="    }" line906="" line907="    /**" line908="     * Set Led state" line909="    */" line910="    //% blockId=hackbitLedSet" line911="    //% block=&quot;led |%pin| to |%state|&quot;" line912="    //% state.min=0 state.max=1" line913="    //% subcategory=Display  group=&quot;Digital&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line914="    export function ledState(pin: DigitalPin, state: OnOff): void {" line915="        pins.digitalWritePin(pin, state);" line916="    }" line917="" line918="    /**" line919="    * Get color from I2C Grove Color Sensor v1.3 (TCS3414CS) or v2.0 (TCS3472)" line920="    * [0;65534]" line921="    * @param selected color" line922="    */" line923="    //% blockId=&quot;grovecolorsensorgetcolor&quot; " line924="    //% block=&quot;color sensor detected %Color&quot;" line925="    //% block.loc.fr=&quot;Valeur de la couleur %Color du capteur de couleur grove&quot;" line926="    //% jsdoc = &quot;Grab sensor value from grove color sensor&quot;" line927="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line928="" line929="    export function color(col: Color): NumberFormat.UInt16BE {" line930="        let nums, red, green, blue, clear: number;" line931="" line932="        if (identifiant == 0) {   // No sensor previously detected" line933="            pins.i2cWriteNumber(57, 132, NumberFormat.UInt8BE, false);" line934="            nums = pins.i2cReadNumber(57, NumberFormat.UInt8BE, false);" line935="            if (nums == 17) {     // Grove Sensor v1.3 detected" line936="                identifiant = 1;" line937="                pins.i2cWriteNumber(57, 129, NumberFormat.UInt8BE, false);" line938="                pins.i2cWriteNumber(57, 0, NumberFormat.UInt8BE, true);" line939="                pins.i2cWriteNumber(57, 135, NumberFormat.UInt8BE, false);" line940="                pins.i2cWriteNumber(57, 48, NumberFormat.UInt8BE, true);" line941="                pins.i2cWriteNumber(57, 128, NumberFormat.UInt8BE, false);" line942="                pins.i2cWriteNumber(57, 3, NumberFormat.UInt8BE, true);" line943="                basic.pause(50);" line944="            } else {" line945="                pins.i2cWriteNumber(41, 146, NumberFormat.UInt8BE, false);" line946="                nums = pins.i2cReadNumber(41, NumberFormat.UInt8BE, false);" line947="                if (nums == 68) {     // Grove Sensor v2 detected " line948="                    identifiant = 2;" line949="                    pins.i2cWriteNumber(41, 129, NumberFormat.UInt8BE, false);" line950="                    pins.i2cWriteNumber(41, 249, NumberFormat.UInt8BE, true);" line951="                    pins.i2cWriteNumber(41, 143, NumberFormat.UInt8BE, false);" line952="                    pins.i2cWriteNumber(41, 2, NumberFormat.UInt8BE, true);" line953="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line954="                    pins.i2cWriteNumber(41, 1, NumberFormat.UInt8BE, true);" line955="                    basic.pause(50);" line956="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line957="                    pins.i2cWriteNumber(41, 3, NumberFormat.UInt8BE, true);" line958="                    basic.pause(500);" line959="                }" line960="            }" line961="        }" line962="" line963="        if (identifiant == 1) {    // Grove Sensor v1.3 detected" line964="            switch (col) {" line965="                case Color.Red:" line966="                    pins.i2cWriteNumber(57, 210, NumberFormat.UInt8BE, false);" line967="                    red = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line968="                    return swap16(red)" line969="                    break" line970="                case Color.Green:" line971="                    pins.i2cWriteNumber(57, 208, NumberFormat.UInt8BE, false);" line972="                    green = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line973="                    return swap16(green)" line974="                    break" line975="                case Color.Blue:" line976="                    pins.i2cWriteNumber(57, 212, NumberFormat.UInt8BE, false);" line977="                    blue = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line978="                    return swap16(blue)" line979="                    break" line980="                case Color.Clear:" line981="                    pins.i2cWriteNumber(57, 214, NumberFormat.UInt8BE, false);" line982="                    clear = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line983="                    return swap16(clear)" line984="                    break" line985="            }" line986="        }" line987="        else if (identifiant == 2) {" line988="            switch (col) {" line989="                case Color.Red:" line990="                    pins.i2cWriteNumber(41, 150, NumberFormat.UInt8BE, false);" line991="                    red = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line992="                    return swap16(red)" line993="                    break" line994="                case Color.Green:" line995="                    pins.i2cWriteNumber(41, 152, NumberFormat.UInt8BE, false);" line996="                    green = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line997="                    return swap16(green)" line998="                    break" line999="                case Color.Blue:" line1000="                    pins.i2cWriteNumber(41, 154, NumberFormat.UInt8BE, false);" line1001="                    blue = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line1002="                    return swap16(blue)" line1003="                    break" line1004="                case Color.Clear:" line1005="                    pins.i2cWriteNumber(41, 148, NumberFormat.UInt8BE, false);" line1006="                    clear = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line1007="                    return swap16(clear)" line1008="                    break" line1009="            }" line1010="            return 0;" line1011="        }" line1012="        return 0;" line1013="    }" line1014="" line1015="    /**" line1016="    * Read color from I2C APDS9960 Color Sensor [0;360]" line1017="    */" line1018="    //% blockId=apds9960_readcolor block=&quot;APDS9960 get color HUE (0~360)&quot;" line1019="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    &#9;" line1020="&#9;" line1021="    export function readColor(): number {" line1022="        if (color_first_init == false) {" line1023="            initModule()" line1024="            colorMode()" line1025="        }" line1026="        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) &amp; 0x1;" line1027="        while (!tmp) {" line1028="            basic.pause(5);" line1029="            tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) &amp; 0x1;" line1030="        }" line1031="        let c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;" line1032="        let r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;" line1033="        let g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;" line1034="        let b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;" line1035="        // map to rgb based on clear channel" line1036="        let avg = c / 3;" line1037="        r = r * 255 / avg;" line1038="        g = g * 255 / avg;" line1039="        b = b * 255 / avg;" line1040="        //let hue = rgb2hue(r, g, b);" line1041="        let hue = rgb2hsl(r, g, b)" line1042="        return hue" line1043="    }" line1044="" line1045="    /**" line1046="    * Read color from I2C APDS9960 Color Sensor " line1047="    * @param selected color" line1048="    */" line1049="    //% block=&quot;APDS9960 color sensor %color detects&quot;" line1050="    //% subcategory=Sensor group=&quot;IIC Port&quot;" line1051="    //% color.fieldEditor=&quot;gridpicker&quot; color.fieldOptions.columns=3" line1052="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    &#9;" line1053="" line1054="    export function checkColor(color: ColorList): boolean {" line1055="        let hue2 = readColor()" line1056="        switch (color) {" line1057="            case ColorList.red:" line1058="                if (hue2 &gt; 330 || hue2 &lt; 20) {" line1059="                    return true" line1060="                }" line1061="                else {" line1062="                    return false" line1063="                }" line1064="                break" line1065="            case ColorList.green:" line1066="                if (hue2 &gt; 110 &amp;&amp; 150 &gt; hue2) {" line1067="                    return true" line1068="                }" line1069="                else {" line1070="                    return false" line1071="                }" line1072="                break" line1073="            case ColorList.blue:" line1074="                if (hue2 &gt; 200 &amp;&amp; 270 &gt; hue2) {" line1075="                    return true" line1076="                }" line1077="                else {" line1078="                    return false" line1079="                }" line1080="                break" line1081="            case ColorList.cyan:" line1082="                if (hue2 &gt; 160 &amp;&amp; 180 &gt; hue2) {" line1083="                    return true" line1084="                }" line1085="                else {" line1086="                    return false" line1087="                }" line1088="                break" line1089="            case ColorList.magenta:" line1090="                if (hue2 &gt; 260 &amp;&amp; 330 &gt; hue2) {" line1091="                    return true" line1092="                }" line1093="                else {" line1094="                    return false" line1095="                }" line1096="                break" line1097="            case ColorList.yellow:" line1098="                if (hue2 &gt; 30 &amp;&amp; 90 &gt; hue2) {" line1099="                    return true" line1100="                }" line1101="                else {" line1102="                    return false" line1103="                }" line1104="                break" line1105="            case ColorList.white:" line1106="                if (hue2 &gt;= 180 &amp;&amp; 200 &gt; hue2) {" line1107="                    return true" line1108="                }" line1109="                else {" line1110="                    return false" line1111="                }" line1112="                break" line1113="        }" line1114="    }" line1115="" line1116="    export class PAJ7620 {" line1117="        private paj7620WriteReg(addr: number, cmd: number) {" line1118="            let buf: Buffer = pins.createBuffer(2);" line1119="            buf[0] = addr;" line1120="            buf[1] = cmd;" line1121="            pins.i2cWriteBuffer(0x73, buf, false);" line1122="        }" line1123="        private paj7620ReadReg(addr: number): number {" line1124="            let buf2: Buffer = pins.createBuffer(1);" line1125="            buf2[0] = addr;" line1126="            pins.i2cWriteBuffer(0x73, buf2, false);" line1127="            buf2 = pins.i2cReadBuffer(0x73, 1, false);" line1128="            return buf2[0];" line1129="        }" line1130="        private paj7620SelectBank(bank: number) {" line1131="            if (bank == 0) this.paj7620WriteReg(0xEF, 0);" line1132="            else if (bank == 1) this.paj7620WriteReg(0xEF, 1);" line1133="        }" line1134="        private paj7620Init() {" line1135="            let temp2 = 0;" line1136="            this.paj7620SelectBank(0);" line1137="            temp2 = this.paj7620ReadReg(0);" line1138="            if (temp2 == 0x20) {" line1139="                for (let o = 0; o &lt; 438; o += 2) {" line1140="                    this.paj7620WriteReg(initRegisterArray[o], initRegisterArray[o + 1]);" line1141="                }" line1142="            }" line1143="            this.paj7620SelectBank(0);" line1144="        }" line1145="        init() {" line1146="            this.paj7620Init();" line1147="            basic.pause(200);" line1148="        }" line1149="        read(): number {" line1150="            let data = 0, result2 = 0;" line1151="            data = this.paj7620ReadReg(0x43);" line1152="            switch (data) {" line1153="                case 0x01:" line1154="                    result2 = GroveGesture.Right;" line1155="                    break;" line1156="                case 0x02:" line1157="                    result2 = GroveGesture.Left;" line1158="                    break;" line1159="                case 0x04:" line1160="                    result2 = GroveGesture.Up;" line1161="                    break;" line1162="                case 0x08:" line1163="                    result2 = GroveGesture.Down;" line1164="                    break;" line1165="                case 0x10:" line1166="                    result2 = GroveGesture.Forward;" line1167="                    break;" line1168="                case 0x20:" line1169="                    result2 = GroveGesture.Backward;" line1170="                    break;" line1171="                case 0x40:" line1172="                    result2 = GroveGesture.Clockwise;" line1173="                    break;" line1174="                case 0x80:" line1175="                    result2 = GroveGesture.Anticlockwise;" line1176="                    break;" line1177="                default:" line1178="                    data = this.paj7620ReadReg(0x44);" line1179="                    if (data == 0x01)" line1180="                        result2 = GroveGesture.Wave;" line1181="                    break;" line1182="            }" line1183="            return result2;" line1184="        }" line1185="    }        " line1186="" line1187="    const gestureEventId = 3100;" line1188="    let lastGesture = GroveGesture.None;" line1189="    let paj7620 = new PAJ7620();" line1190="    /**" line1191="        * Do something when a gesture is detected" line1192="        * @param gesture type of gesture to detect" line1193="        * @param handler code to run" line1194="    */" line1195="    //% blockId= gesture_create_event block=&quot;on gesture sensor is %gesture&quot;" line1196="    //% gesture.fieldEditor=&quot;gridpicker&quot; gesture.fieldOptions.columns=3" line1197="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532 icon=&quot;\uf1eb&quot;    " line1198="    export function onGesture(gesture: GroveGesture, handler: () =&gt; void) {" line1199="        control.onEvent(gestureEventId, gesture, handler);" line1200="        if(gesture_first_init){" line1201="            paj7620.init();" line1202="            gesture_first_init = false" line1203="        }" line1204="        control.inBackground(() =&gt; {" line1205="            while (true) {" line1206="                const gesture = paj7620.read();" line1207="                if (gesture != lastGesture) {" line1208="                    lastGesture = gesture;" line1209="                    control.raiseEvent(gestureEventId, lastGesture);" line1210="                }" line1211="                basic.pause(100);" line1212="            }" line1213="        })" line1214="    }" line1215="" line1216="    /**" line1217="     * Create a new driver Grove - 4-Digit Display" line1218="     * @param clkPin value of clk pin number" line1219="     * @param dataPin value of data pin number" line1220="     */" line1221="    //% blockId=hackbit_tm1637_create block=&quot;4-Digit Display at|%clkPin|and|%dataPin&quot;" line1222="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1223="    //% weight=60" line1224="    export function digit_createDisplay(clkPin: DigitalPin, dataPin: DigitalPin): void {" line1225="        digit_buf = pins.createBuffer(4);" line1226="        digit_clkPin = clkPin;" line1227="        digit_dataPin = dataPin;" line1228="        digit_brightnessLevel = 0;" line1229="        digit_pointFlag = false;" line1230="        digit_clear();" line1231="    }" line1232="" line1233="    /**" line1234="    * Show a 4 digits number on display" line1235="    * @param dispData value of number" line1236="    */" line1237="    //% blockId=hackbit_tm1637_display_number block=&quot;show number|%dispData&quot;" line1238="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1239="    //% weight=59" line1240="    export function digit_show(dispData: number) {" line1241="        let compare_01: number = dispData % 100;" line1242="        let compare_001: number = dispData % 1000;" line1243="" line1244="        if (dispData &lt; 10) {" line1245="            digit_bit(dispData, 3);" line1246="            digit_bit(0x7f, 2);" line1247="            digit_bit(0x7f, 1);" line1248="            digit_bit(0x7f, 0);" line1249="        }" line1250="        else if (dispData &lt; 100) {" line1251="            digit_bit(dispData % 10, 3);" line1252="            if (dispData &gt; 90) {" line1253="                digit_bit(9, 2);" line1254="            } else {" line1255="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line1256="            }" line1257="" line1258="            digit_bit(0x7f, 1);" line1259="            digit_bit(0x7f, 0);" line1260="        }" line1261="        else if (dispData &lt; 1000) {" line1262="            digit_bit(dispData % 10, 3);" line1263="            if (compare_01 &gt; 90) {" line1264="                digit_bit(9, 2);" line1265="            } else {" line1266="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line1267="            }" line1268="            if (compare_001 &gt; 900) {" line1269="                digit_bit(9, 1);" line1270="            } else {" line1271="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line1272="            }" line1273="            digit_bit(0x7f, 0);" line1274="        }" line1275="        else if (dispData &lt; 10000) {" line1276="            digit_bit(dispData % 10, 3);" line1277="            if (compare_01 &gt; 90) {" line1278="                digit_bit(9, 2);" line1279="            } else {" line1280="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line1281="            }" line1282="            if (compare_001 &gt; 900) {" line1283="                digit_bit(9, 1);" line1284="            } else {" line1285="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line1286="            }" line1287="            if (dispData &gt; 9000) {" line1288="                digit_bit(9, 0);" line1289="            } else {" line1290="                digit_bit(Math.floor(dispData / 1000) % 10, 0);" line1291="            }" line1292="        }" line1293="        else {" line1294="            digit_bit(9, 3);" line1295="            digit_bit(9, 2);" line1296="            digit_bit(9, 1);" line1297="            digit_bit(9, 0);" line1298="        }" line1299="    }" line1300="" line1301="    /**" line1302="     * Set the brightness level of display at from 0 to 7" line1303="     * @param level value of brightness light level" line1304="     */" line1305="    //% blockId=hackbit_tm1637_set_display_level block=&quot;brightness level to|%level&quot;" line1306="    //% level.min=0 level.max=7" line1307="    //% weight=58" line1308="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;     " line1309="    export function digit_set(level: number) {" line1310="        digit_brightnessLevel = level;" line1311="" line1312="        digit_bit(digit_buf[0], 0x00);" line1313="        digit_bit(digit_buf[1], 0x01);" line1314="        digit_bit(digit_buf[2], 0x02);" line1315="        digit_bit(digit_buf[3], 0x03);" line1316="    }" line1317="" line1318="    /**" line1319="     * Show a single number from 0 to 9 at a specified digit of Grove - 4-Digit Display" line1320="     * @param dispData value of number" line1321="     * @param bitAddr value of bit number" line1322="     */" line1323="    //% blockId=grove_tm1637_display_bit block=&quot;%strip|show single number|%dispData|at digit|%bitAddr&quot;" line1324="    //% dispData.min=0 dispData.max=9" line1325="    //% bitAddr.min=0 bitAddr.max=3" line1326="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1327="    //% advanced=false" line1328="    export function digit_bit(dispData: number, bitAddr: number) {" line1329="        if ((dispData == 0x7f) || ((dispData &lt;= 9) &amp;&amp; (bitAddr &lt;= 3))) {" line1330="            let segData = 0;" line1331="" line1332="            segData = digit_coding(dispData);" line1333="            digit_start();" line1334="            digit_writeByte(0x44);" line1335="            digit_stop();" line1336="            digit_start();" line1337="            digit_writeByte(bitAddr | 0xc0);" line1338="            digit_writeByte(segData);" line1339="            digit_stop();" line1340="            digit_start();" line1341="            digit_writeByte(0x88 + digit_brightnessLevel);" line1342="            digit_stop();" line1343="" line1344="            digit_buf[bitAddr] = dispData;" line1345="        }" line1346="    }" line1347="" line1348="    /**" line1349="     * Turn on or off the colon point on Grove - 4-Digit Display" line1350="     * @param pointEn value of point switch" line1351="     */" line1352="    //% blockId=grove_tm1637_display_point block=&quot;%strip|turn|%point|colon point&quot;" line1353="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;   " line1354="    //% advanced=false" line1355="    export function digit_point(point: boolean) {" line1356="        digit_pointFlag = point;" line1357="" line1358="        digit_bit(digit_buf[0], 0x00);" line1359="        digit_bit(digit_buf[1], 0x01);" line1360="        digit_bit(digit_buf[2], 0x02);" line1361="        digit_bit(digit_buf[3], 0x03);" line1362="    }" line1363="" line1364="    /**" line1365="     * Clear the display" line1366="     */" line1367="    //% blockId=grove_tm1637_display_clear block=&quot;%strip|clear&quot;" line1368="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#F57513 icon=&quot;\uf1eb&quot;    " line1369="    //% advanced=false" line1370="    export function digit_clear() {" line1371="        digit_bit(0x7f, 0x00);" line1372="        digit_bit(0x7f, 0x01);" line1373="        digit_bit(0x7f, 0x02);" line1374="        digit_bit(0x7f, 0x03);" line1375="    }" line1376="" line1377="    /*" line1378="     * Private functions" line1379="     */" line1380="    function swap16(val: NumberFormat.UInt16BE) {" line1381="        return ((val &amp; 0xFF) &lt;&lt; 8)" line1382="            | ((val &gt;&gt; 8) &amp; 0xFF);" line1383="    }" line1384="" line1385="    function digit_writeByte(wrData: number) {" line1386="        for (let p = 0; p &lt; 8; p++) {" line1387="            pins.digitalWritePin(digit_clkPin, 0);" line1388="            if (wrData &amp; 0x01) pins.digitalWritePin(digit_dataPin, 1);" line1389="            else pins.digitalWritePin(digit_dataPin, 0);" line1390="            wrData &gt;&gt;= 1;" line1391="            pins.digitalWritePin(digit_clkPin, 1);" line1392="        }" line1393="" line1394="        pins.digitalWritePin(digit_clkPin, 0); // Wait for ACK" line1395="        pins.digitalWritePin(digit_dataPin, 1);" line1396="        pins.digitalWritePin(digit_clkPin, 1);" line1397="    }" line1398="" line1399="    function digit_start() {" line1400="        pins.digitalWritePin(digit_clkPin, 1);" line1401="        pins.digitalWritePin(digit_dataPin, 1);" line1402="        pins.digitalWritePin(digit_dataPin, 0);" line1403="        pins.digitalWritePin(digit_clkPin, 0);" line1404="    }" line1405="" line1406="    function digit_stop() {" line1407="        pins.digitalWritePin(digit_clkPin, 0);" line1408="        pins.digitalWritePin(digit_dataPin, 0);" line1409="        pins.digitalWritePin(digit_clkPin, 1);" line1410="        pins.digitalWritePin(digit_dataPin, 1);" line1411="    }" line1412="" line1413="    function digit_coding(dispData: number): number {" line1414="        let pointData = 0;" line1415="" line1416="        if (digit_pointFlag == true) pointData = 0x80;" line1417="        else if (digit_pointFlag == false) pointData = 0;" line1418="" line1419="        if (dispData == 0x7f) dispData = 0x00 + pointData;" line1420="        else dispData = TubeTab[dispData] + pointData;" line1421="" line1422="        return dispData;" line1423="    }" line1424="" line1425="    /***********   APDS 9960  **********/" line1426="    function i2cwrite_color(addr: number, reg: number, value: number) {" line1427="        let buf3 = pins.createBuffer(2)" line1428="        buf3[0] = reg" line1429="        buf3[1] = value" line1430="        pins.i2cWriteBuffer(addr, buf3)" line1431="    }" line1432="" line1433="    function i2cread_color(addr: number, reg: number) {" line1434="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line1435="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line1436="        return val;" line1437="    }" line1438="" line1439="    function rgb2hsl(color_r: number, color_g: number, color_b: number): number {" line1440="        let Hue = 0" line1441="        // Convert the RGB value to the middle value of [0, 1]." line1442="        let R2 = color_r * 100 / 255;   //Since H25 does not support floating point operations, it is calculated by zooming 100 times, and the following calculations are also zooming 100 times" line1443="        let G = color_g * 100 / 255;" line1444="        let B2 = color_b * 100 / 255;" line1445="" line1446="        let maxVal = Math.max(R2, Math.max(G, B2))//Find the maximum of R, G, and B" line1447="        let minVal = Math.min(R2, Math.min(G, B2)) //Find the minimum of R, G and B" line1448="" line1449="        let Delta = maxVal - minVal;  //△ = Max - Min" line1450="" line1451="        /***********   Calculate Hue  **********/" line1452="        if (Delta &lt; 0) {" line1453="            Hue = 0;" line1454="        }" line1455="        else if (maxVal == R2 &amp;&amp; G &gt;= B2) //Maximum value is red" line1456="        {" line1457="            Hue = (60 * ((G - B2) * 100 / Delta)) / 100;  //Magnify 100 times" line1458="        }" line1459="        else if (maxVal == R2 &amp;&amp; G &lt; B2) {" line1460="            Hue = (60 * ((G - B2) * 100 / Delta) + 360 * 100) / 100;" line1461="        }" line1462="        else if (maxVal == G) //Maximum value is green" line1463="        {" line1464="            Hue = (60 * ((B2 - R2) * 100 / Delta) + 120 * 100) / 100;" line1465="        }" line1466="        else if (maxVal == B2) {" line1467="            Hue = (60 * ((R2 - G) * 100 / Delta) + 240 * 100) / 100;" line1468="        }" line1469="        return Hue" line1470="    }" line1471="" line1472="    function initModule(): void {" line1473="        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252) // default inte time 4x2.78ms" line1474="        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03) // todo: make gain adjustable" line1475="        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00) // put everything off" line1476="        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00) // disable gesture mode" line1477="        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00) // clear all interrupt" line1478="        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01) // clear all interrupt" line1479="        color_first_init = true" line1480="    }" line1481="" line1482="    function colorMode(): void {" line1483="        let tmp2 = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;" line1484="        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp2);" line1485="    }" line1486="}" numlines="1487"></mutation></block></statement></block></xml>