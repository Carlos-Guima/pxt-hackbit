<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="mNJXRjIhkne!UL3dZ)T#" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="a(Rr;MBw8C2^AAU~m%60" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace hackbit {" line1="    const initRegisterArray: number[] = [" line2="        0xEF, 0x00, 0x32, 0x29, 0x33, 0x01, 0x34, 0x00, 0x35, 0x01, 0x36, 0x00, 0x37, 0x07, 0x38, 0x17," line3="        0x39, 0x06, 0x3A, 0x12, 0x3F, 0x00, 0x40, 0x02, 0x41, 0xFF, 0x42, 0x01, 0x46, 0x2D, 0x47, 0x0F," line4="        0x48, 0x3C, 0x49, 0x00, 0x4A, 0x1E, 0x4B, 0x00, 0x4C, 0x20, 0x4D, 0x00, 0x4E, 0x1A, 0x4F, 0x14," line5="        0x50, 0x00, 0x51, 0x10, 0x52, 0x00, 0x5C, 0x02, 0x5D, 0x00, 0x5E, 0x10, 0x5F, 0x3F, 0x60, 0x27," line6="        0x61, 0x28, 0x62, 0x00, 0x63, 0x03, 0x64, 0xF7, 0x65, 0x03, 0x66, 0xD9, 0x67, 0x03, 0x68, 0x01," line7="        0x69, 0xC8, 0x6A, 0x40, 0x6D, 0x04, 0x6E, 0x00, 0x6F, 0x00, 0x70, 0x80, 0x71, 0x00, 0x72, 0x00," line8="        0x73, 0x00, 0x74, 0xF0, 0x75, 0x00, 0x80, 0x42, 0x81, 0x44, 0x82, 0x04, 0x83, 0x20, 0x84, 0x20," line9="        0x85, 0x00, 0x86, 0x10, 0x87, 0x00, 0x88, 0x05, 0x89, 0x18, 0x8A, 0x10, 0x8B, 0x01, 0x8C, 0x37," line10="        0x8D, 0x00, 0x8E, 0xF0, 0x8F, 0x81, 0x90, 0x06, 0x91, 0x06, 0x92, 0x1E, 0x93, 0x0D, 0x94, 0x0A," line11="        0x95, 0x0A, 0x96, 0x0C, 0x97, 0x05, 0x98, 0x0A, 0x99, 0x41, 0x9A, 0x14, 0x9B, 0x0A, 0x9C, 0x3F," line12="        0x9D, 0x33, 0x9E, 0xAE, 0x9F, 0xF9, 0xA0, 0x48, 0xA1, 0x13, 0xA2, 0x10, 0xA3, 0x08, 0xA4, 0x30," line13="        0xA5, 0x19, 0xA6, 0x10, 0xA7, 0x08, 0xA8, 0x24, 0xA9, 0x04, 0xAA, 0x1E, 0xAB, 0x1E, 0xCC, 0x19," line14="        0xCD, 0x0B, 0xCE, 0x13, 0xCF, 0x64, 0xD0, 0x21, 0xD1, 0x0F, 0xD2, 0x88, 0xE0, 0x01, 0xE1, 0x04," line15="        0xE2, 0x41, 0xE3, 0xD6, 0xE4, 0x00, 0xE5, 0x0C, 0xE6, 0x0A, 0xE7, 0x00, 0xE8, 0x00, 0xE9, 0x00," line16="        0xEE, 0x07, 0xEF, 0x01, 0x00, 0x1E, 0x01, 0x1E, 0x02, 0x0F, 0x03, 0x10, 0x04, 0x02, 0x05, 0x00," line17="        0x06, 0xB0, 0x07, 0x04, 0x08, 0x0D, 0x09, 0x0E, 0x0A, 0x9C, 0x0B, 0x04, 0x0C, 0x05, 0x0D, 0x0F," line18="        0x0E, 0x02, 0x0F, 0x12, 0x10, 0x02, 0x11, 0x02, 0x12, 0x00, 0x13, 0x01, 0x14, 0x05, 0x15, 0x07," line19="        0x16, 0x05, 0x17, 0x07, 0x18, 0x01, 0x19, 0x04, 0x1A, 0x05, 0x1B, 0x0C, 0x1C, 0x2A, 0x1D, 0x01," line20="        0x1E, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x25, 0x01, 0x26, 0x00, 0x27, 0x39, 0x28, 0x7F," line21="        0x29, 0x08, 0x30, 0x03, 0x31, 0x00, 0x32, 0x1A, 0x33, 0x1A, 0x34, 0x07, 0x35, 0x07, 0x36, 0x01," line22="        0x37, 0xFF, 0x38, 0x36, 0x39, 0x07, 0x3A, 0x00, 0x3E, 0xFF, 0x3F, 0x00, 0x40, 0x77, 0x41, 0x40," line23="        0x42, 0x00, 0x43, 0x30, 0x44, 0xA0, 0x45, 0x5C, 0x46, 0x00, 0x47, 0x00, 0x48, 0x58, 0x4A, 0x1E," line24="        0x4B, 0x1E, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0xA0, 0x4F, 0x80, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00," line25="        0x53, 0x00, 0x54, 0x00, 0x57, 0x80, 0x59, 0x10, 0x5A, 0x08, 0x5B, 0x94, 0x5C, 0xE8, 0x5D, 0x08," line26="        0x5E, 0x3D, 0x5F, 0x99, 0x60, 0x45, 0x61, 0x40, 0x63, 0x2D, 0x64, 0x02, 0x65, 0x96, 0x66, 0x00," line27="        0x67, 0x97, 0x68, 0x01, 0x69, 0xCD, 0x6A, 0x01, 0x6B, 0xB0, 0x6C, 0x04, 0x6D, 0x2C, 0x6E, 0x01," line28="        0x6F, 0x32, 0x71, 0x00, 0x72, 0x01, 0x73, 0x35, 0x74, 0x00, 0x75, 0x33, 0x76, 0x31, 0x77, 0x01," line29="        0x7C, 0x84, 0x7D, 0x03, 0x7E, 0x01" line30="    ];" line31="" line32="    export enum MotorDirection {" line33="        //% block=&quot;Forward&quot;" line34="        Forward = 1," line35="        //% block=&quot;Backward&quot;" line36="        Reverse = 2," line37="        //% block=&quot;Stop&quot;" line38="        Stop = 0" line39="    }" line40="" line41="    export enum OnOff {" line42="        //% block=&quot;On&quot;" line43="        On = 1," line44="        //% block=&quot;Off&quot;" line45="        Off = 0" line46="    }" line47="" line48="    export enum BP {" line49="        //% block=&quot;BPA&quot;" line50="        BPA = 1," line51="        //% block=&quot;BPB&quot;" line52="        BPB = 0" line53="    }" line54="" line55="    export enum RobotDirection {" line56="        //% block=&quot;Forward&quot;" line57="        Forward," line58="        //% block=&quot;Backward&quot;" line59="        Reverse," line60="        //% block=&quot;Turn Right&quot;" line61="        TurnRigh," line62="        //% block=&quot;Turn Left&quot;" line63="        TurnLef," line64="        //% block=&quot;Rotate Right&quot;" line65="        RotateRight," line66="        //% block=&quot;Rotate Left&quot;" line67="        RotateLef," line68="        //% block=&quot;Stop&quot;" line69="        Stop" line70="    }" line71="" line72="    export enum Motors {" line73="        //%blockId=A4_Robot_Driver_motor_one" line74="        //% block=&quot;left motor&quot;" line75="        Motor1," line76="        //%blockId=A4_Robot_Driver_motor_two" line77="        //% block=&quot;right motor&quot;" line78="        Motor2," line79="        //%blockId=A4_Robot_Driver_motor_full" line80="        //% block=&quot;left and right motor&quot;" line81="        MotorFull" line82="    }" line83="" line84="    export enum Color {" line85="        //% block=&quot;Red&quot;" line86="        Red," line87="        //% block=&quot;Green&quot;" line88="        Green," line89="        //% block=&quot;Blue&quot;" line90="        Blue," line91="        //% block=&quot;Clear&quot;" line92="        Clear" line93="    }" line94="" line95="    export enum GroveGesture {" line96="        //% block=None" line97="        None = 0," line98="        //% block=Right" line99="        Right = 1," line100="        //% block=Left" line101="        Left = 2," line102="        //% block=Up" line103="        Up = 3," line104="        //% block=Down" line105="        Down = 4," line106="        //% block=Forward" line107="        Forward = 5," line108="        //% block=Backward" line109="        Backward = 6," line110="        //% block=Clockwise" line111="        Clockwise = 7," line112="        //% block=Anticlockwise" line113="        Anticlockwise = 8," line114="        //% block=Wave" line115="        Wave = 9" line116="    }" line117="" line118="    export let _speed_left = 700; //1023 = 100% speed" line119="    export let _speed_right = 700;" line120="    export let _dir_right = 1; //0 = stop, 1 = forward, 2 = backward" line121="    export let _dir_left = 1;" line122="    export let identifiant = 0;" line123="    export let grovegestureinit = 0;" line124="" line125="    let TubeTab: number[] = [" line126="        0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07," line127="        0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71" line128="    ];" line129="" line130="    export let digit_clkPin: DigitalPin;" line131="    export let digit_dataPin: DigitalPin;" line132="    export let digit_brightnessLevel: number;" line133="    export let digit_pointFlag: boolean;" line134="    export let digit_buf: Buffer;" line135="" line136="    /**" line137="     * Control Robot speed [0-100%]" line138="     * @param dir direction" line139="     * @param speed speed in %" line140="     */" line141="    //% blockId=RobotDriverRobotMove" line142="    //% block=&quot;move %dir| speed %speed&quot;" line143="    //% speed.min=0 speed.max=100" line144="    //% parts=&quot;RobotDriver&quot; advanced=false" line145="    //% speed.defl=75" line146="    //% group=&quot;Motors&quot;" line147="    export function robotMove(dir: RobotDirection, speed: number): void {" line148="        setSpeed(Motors.MotorFull, speed);" line149="        switch (dir) {" line150="            case RobotDirection.Forward:" line151="                setDir(Motors.MotorFull, MotorDirection.Forward);" line152="                break" line153="            case RobotDirection.Reverse:" line154="                setDir(Motors.MotorFull, MotorDirection.Reverse);" line155="                break" line156="            case RobotDirection.RotateRight:" line157="                setDir(Motors.Motor1, MotorDirection.Forward);" line158="                setDir(Motors.Motor2, MotorDirection.Reverse);" line159="                break" line160="            case RobotDirection.RotateLef:" line161="                setDir(Motors.Motor1, MotorDirection.Reverse);" line162="                setDir(Motors.Motor2, MotorDirection.Forward);" line163="                break" line164="            case RobotDirection.TurnRigh:" line165="                setDir(Motors.Motor1, MotorDirection.Forward);" line166="                setDir(Motors.Motor2, MotorDirection.Stop);" line167="                break" line168="            case RobotDirection.TurnLef:" line169="                setDir(Motors.Motor1, MotorDirection.Stop);" line170="                setDir(Motors.Motor2, MotorDirection.Forward);" line171="                break" line172="            case RobotDirection.Stop:" line173="                setDir(Motors.MotorFull, MotorDirection.Stop);" line174="                break" line175="        }" line176="        setMotors();" line177="    }" line178="" line179="" line180="    /**" line181="     * Change the motor direction" line182="     * @param motor selection (left, right)" line183="     * @param dir rotation direction (forward, backward)" line184="     */" line185="    //% blockId=RobotDrivermotordir" line186="    //% block=&quot;set %motor| %dir&quot;" line187="    //% parts=&quot;RobotDriver&quot; advanced=false" line188="    //% motor.defl=MotorFull" line189="    //% group=&quot;Motors&quot;" line190="    export function motorDir(motor: Motors, dir: MotorDirection): void {" line191="        setDir(motor, dir);" line192="        setMotors();" line193="    }" line194="" line195="    /**" line196="     * Change the motor speed [0-100%]" line197="     * @param motor selection (left, right)" line198="     * @param new speed (0-100%)" line199="     */" line200="" line201="    //% blockId=robotdrivermotorspeed" line202="    //% block=&quot;set %motor| to %speed %&quot;" line203="    //% speed.min=0 speed.max=100" line204="    //% parts=&quot;A4_Robot_Driver&quot; advanced=false" line205="    //% speed.defl=75" line206="    //% group=&quot;Motors&quot;" line207="    export function motorSpeed(motor: Motors, speed: number): void {" line208="        setSpeed(motor, speed);" line209="        setMotors();" line210="    }" line211="" line212="    /**" line213="     * Stop both motors" line214="    */" line215="    //% blockId=RobotDriverRobotStop" line216="    //% block=&quot;stop both motors&quot;" line217="    //% group=&quot;Motors&quot;" line218="    export function motorStop(): void {" line219="        robotMove(hackbit.RobotDirection.Stop, 0)" line220="    }" line221="    /**" line222="     * get distance from ultrasonic range sensor [cm]" line223="     * @param pin Input pin" line224="     */" line225="    //% blockId=RobotDriverultrasonic_cm " line226="    //% block=&quot;ultrasonic distance|%name| (cm)&quot;" line227="    //% name.fieldEditor=&quot;gridpicker&quot; " line228="    //% name.fieldOptions.columns=5" line229="    //% name.fieldOptions.tooltips=&quot;false&quot;" line230="    //% name.fieldOptions.width=&quot;0&quot;" line231="    //% group=&quot;Sensors&quot;" line232="    export function measureDistanceCentimeter(name: DigitalPin): number {" line233="        let duration = 0;" line234="        let distance = 0;" line235="        pins.digitalWritePin(name, 0); //make sure pin is low" line236="        control.waitMicros(2);" line237="        pins.digitalWritePin(name, 1); //send echo" line238="        control.waitMicros(20);" line239="        pins.digitalWritePin(name, 0);" line240="        duration = pins.pulseIn(name, PulseValue.High, 50000); // Max duration 50 ms - receive echo" line241="        distance = duration * 153 / 29 / 2 / 100;" line242="        Math.constrain(distance, 0, 500);" line243="        return distance;" line244="    }" line245="" line246="    /**" line247="     * Get analog potentiometer value [0-1023]" line248="    */" line249="    //% blockId=hackbitPotargRead" line250="    //% block=&quot;potentiometer |%pin|&quot;" line251="    //% group=&quot;Sensors&quot;" line252="    export function potarValue(pin: AnalogPin): number {" line253="        return pins.analogReadPin(pin);" line254="    }" line255="" line256="    /**" line257="     * Get collision sensor state [0-1]" line258="    */" line259="    //% blockId=hackbitCollisionRead" line260="    //% block=&quot;collision sensor |%pin|&quot;" line261="    //% group=&quot;Sensors&quot;" line262="    export function collisionSensor(pin: BP): boolean {" line263="        if (pin)" line264="            return input.buttonIsPressed(Button.A);" line265="        return input.buttonIsPressed(Button.B);" line266="    }" line267="" line268="    /**" line269="     * Get line sensor state [0-1]" line270="    */" line271="    //% blockId=hackbitLineRead" line272="    //% block=&quot;line sensor |%pin|&quot;" line273="    //% group=&quot;Sensors&quot;" line274="    export function detectline(pin: DigitalPin): number {" line275="        return pins.digitalReadPin(pin);" line276="    }" line277="" line278="    /**" line279="     * Get button state [0-1]" line280="    */" line281="    //% blockId=hackbitButtonRead" line282="    //% block=&quot;button |%pin|&quot;" line283="    //% group=&quot;Sensors&quot;" line284="    export function buttonState(pin: DigitalPin): number {" line285="        return pins.digitalReadPin(pin);" line286="    }" line287="" line288="    /**" line289="     * Set the servomotor position [0-180deg]" line290="     * @param pin servomotor pin (right or left)" line291="     */" line292="    //% blockId=RobotDriverservodegrees" line293="    //% block=&quot;servomotor |%pin| to |%angle| degree&quot;" line294="    //% parts=&quot;RobotDriver&quot; advanced=false" line295="    //% angle.shadow=&quot;protractorPicker&quot;" line296="    //% angle.defl=90" line297="    //% group=&quot;Actuator&quot;" line298="    export function setServoMotor(pin: AnalogPin, angle: number): void {" line299="        pins.servoWritePin(pin, Math.constrain(angle, 0, 180));" line300="    }" line301="" line302="    /**" line303="    * Get color from I2C Grove Color Sensor v1.3 or v2.0" line304="    * [0;65534]" line305="    * @param selected color" line306="    */" line307="    //% blockId=&quot;grovecolorsensorgetcolor&quot; " line308="    //% block=&quot;color %Color&quot;" line309="    //% group=&quot;Sensors&quot;" line310="    //% block.loc.fr=&quot;Valeur de la couleur %Color du capteur de couleur grove&quot;" line311="    //% jsdoc = &quot;Grab sensor value from grove color sensor&quot;" line312="    export function color(col: Color): NumberFormat.UInt16BE {" line313="        let nums, red, green, blue, clear: number;" line314="" line315="        if (identifiant == 0) {   // No sensor previously detected" line316="            pins.i2cWriteNumber(57, 132, NumberFormat.UInt8BE, false);" line317="            nums = pins.i2cReadNumber(57, NumberFormat.UInt8BE, false);" line318="            if (nums == 17) {     // Grove Sensor v1.3 detected" line319="                identifiant = 1;" line320="                pins.i2cWriteNumber(57, 129, NumberFormat.UInt8BE, false);" line321="                pins.i2cWriteNumber(57, 0, NumberFormat.UInt8BE, true);" line322="                pins.i2cWriteNumber(57, 135, NumberFormat.UInt8BE, false);" line323="                pins.i2cWriteNumber(57, 48, NumberFormat.UInt8BE, true);" line324="                pins.i2cWriteNumber(57, 128, NumberFormat.UInt8BE, false);" line325="                pins.i2cWriteNumber(57, 3, NumberFormat.UInt8BE, true);" line326="                basic.pause(50);" line327="            } else {" line328="                pins.i2cWriteNumber(41, 146, NumberFormat.UInt8BE, false);" line329="                nums = pins.i2cReadNumber(41, NumberFormat.UInt8BE, false);" line330="                if (nums == 68) {     // Grove Sensor v2 detected " line331="                    identifiant = 2;" line332="                    pins.i2cWriteNumber(41, 129, NumberFormat.UInt8BE, false);" line333="                    pins.i2cWriteNumber(41, 249, NumberFormat.UInt8BE, true);" line334="                    pins.i2cWriteNumber(41, 143, NumberFormat.UInt8BE, false);" line335="                    pins.i2cWriteNumber(41, 2, NumberFormat.UInt8BE, true);" line336="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line337="                    pins.i2cWriteNumber(41, 1, NumberFormat.UInt8BE, true);" line338="                    basic.pause(50);" line339="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line340="                    pins.i2cWriteNumber(41, 3, NumberFormat.UInt8BE, true);" line341="                    basic.pause(500);" line342="                }" line343="            }" line344="        }" line345="" line346="        if (identifiant == 1) {    // Grove Sensor v1.3 detected" line347="            switch (col) {" line348="                case Color.Red:" line349="                    pins.i2cWriteNumber(57, 210, NumberFormat.UInt8BE, false);" line350="                    red = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line351="                    return swap16(red)" line352="                    break" line353="                case Color.Green:" line354="                    pins.i2cWriteNumber(57, 208, NumberFormat.UInt8BE, false);" line355="                    green = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line356="                    return swap16(green)" line357="                    break" line358="                case Color.Blue:" line359="                    pins.i2cWriteNumber(57, 212, NumberFormat.UInt8BE, false);" line360="                    blue = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line361="                    return swap16(blue)" line362="                    break" line363="                case Color.Clear:" line364="                    pins.i2cWriteNumber(57, 214, NumberFormat.UInt8BE, false);" line365="                    clear = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line366="                    return swap16(clear)" line367="                    break" line368="            }" line369="        }" line370="        else if (identifiant == 2) {" line371="            switch (col) {" line372="                case Color.Red:" line373="                    pins.i2cWriteNumber(41, 150, NumberFormat.UInt8BE, false);" line374="                    red = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line375="                    return swap16(red)" line376="                    break" line377="                case Color.Green:" line378="                    pins.i2cWriteNumber(41, 152, NumberFormat.UInt8BE, false);" line379="                    green = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line380="                    return swap16(green)" line381="                    break" line382="                case Color.Blue:" line383="                    pins.i2cWriteNumber(41, 154, NumberFormat.UInt8BE, false);" line384="                    blue = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line385="                    return swap16(blue)" line386="                    break" line387="                case Color.Clear:" line388="                    pins.i2cWriteNumber(41, 148, NumberFormat.UInt8BE, false);" line389="                    clear = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line390="                    return swap16(clear)" line391="                    break" line392="            }" line393="            return 0;" line394="        }" line395="        return 0;" line396="    }" line397="" line398="    /**" line399="     * Create a new driver Grove - 4-Digit Display" line400="     * @param clkPin value of clk pin number" line401="     * @param dataPin value of data pin number" line402="     */" line403="    //% blockId=hackbit_tm1637_create block=&quot;4-Digit Display at|%clkPin|and|%dataPin&quot;" line404="    //% group=&quot;Display&quot;" line405="    //% weight=60" line406="    export function digit_createDisplay(clkPin: DigitalPin, dataPin: DigitalPin): void {" line407="        digit_buf = pins.createBuffer(4);" line408="        digit_clkPin = clkPin;" line409="        digit_dataPin = dataPin;" line410="        digit_brightnessLevel = 0;" line411="        digit_pointFlag = false;" line412="        digit_clear();" line413="    }" line414="" line415="    /**" line416="     * Detect and recognize the gestures from Grove - Gesture" line417="     * None:0" line418="     * Right:1" line419="     * Left:2" line420="     * Up:3" line421="     * Down:4" line422="     * Forward:5" line423="     * Backward:6" line424="     * Clockwise:7" line425="     * Anticlockwise:8" line426="     * Wave:9" line427="     */" line428="    //% blockId=hackbitGroveGesture" line429="    //% block=&quot;grove gesture&quot;" line430="    //% group=&quot;Sensors&quot;" line431="    export function grove_gesture_reads(): number {" line432="        let data = 0, result = 0;" line433="" line434="        if (grovegestureinit == 0) {" line435="            paj7620Init();" line436="            basic.pause(200);" line437="            grovegestureinit = 1;" line438="        }" line439="" line440="        data = paj7620ReadReg(0x43);" line441="        switch (data) {" line442="            case 0x01:" line443="                result = GroveGesture.Right;" line444="                break;" line445="" line446="            case 0x02:" line447="                result = GroveGesture.Left;" line448="                break;" line449="" line450="            case 0x04:" line451="                result = GroveGesture.Up;" line452="                break;" line453="" line454="            case 0x08:" line455="                result = GroveGesture.Down;" line456="                break;" line457="" line458="            case 0x10:" line459="                result = GroveGesture.Forward;" line460="                break;" line461="" line462="            case 0x20:" line463="                result = GroveGesture.Backward;" line464="                break;" line465="" line466="            case 0x40:" line467="                result = GroveGesture.Clockwise;" line468="                break;" line469="" line470="            case 0x80:" line471="                result = GroveGesture.Anticlockwise;" line472="                break;" line473="" line474="            default:" line475="                data = paj7620ReadReg(0x44);" line476="                if (data == 0x01)" line477="                    result = GroveGesture.Wave;" line478="                break;" line479="        }" line480="        return result;" line481="    }" line482="" line483="    /**" line484="     * Set Led state" line485="    */" line486="    //% blockId=hackbitLedSet" line487="    //% block=&quot;led |%pin| to |%state|&quot;" line488="    //% state.min=0 state.max=1" line489="    //% group=&quot;Display&quot;" line490="    export function ledState(pin: DigitalPin, state: OnOff): void {" line491="        pins.digitalWritePin(pin, state);" line492="    }" line493="" line494="    /**" line495="    * Show a 4 digits number on display" line496="    * @param dispData value of number" line497="    */" line498="    //% blockId=hackbit_tm1637_display_number block=&quot;show number|%dispData&quot;" line499="    //% group=&quot;Display&quot;" line500="    //% weight=59" line501="    export function digit_show(dispData: number) {" line502="        let compare_01: number = dispData % 100;" line503="        let compare_001: number = dispData % 1000;" line504="" line505="        if (dispData &lt; 10) {" line506="            digit_bit(dispData, 3);" line507="            digit_bit(0x7f, 2);" line508="            digit_bit(0x7f, 1);" line509="            digit_bit(0x7f, 0);" line510="        }" line511="        else if (dispData &lt; 100) {" line512="            digit_bit(dispData % 10, 3);" line513="            if (dispData &gt; 90) {" line514="                digit_bit(9, 2);" line515="            } else {" line516="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line517="            }" line518="" line519="            digit_bit(0x7f, 1);" line520="            digit_bit(0x7f, 0);" line521="        }" line522="        else if (dispData &lt; 1000) {" line523="            digit_bit(dispData % 10, 3);" line524="            if (compare_01 &gt; 90) {" line525="                digit_bit(9, 2);" line526="            } else {" line527="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line528="            }" line529="            if (compare_001 &gt; 900) {" line530="                digit_bit(9, 1);" line531="            } else {" line532="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line533="            }" line534="            digit_bit(0x7f, 0);" line535="        }" line536="        else if (dispData &lt; 10000) {" line537="            digit_bit(dispData % 10, 3);" line538="            if (compare_01 &gt; 90) {" line539="                digit_bit(9, 2);" line540="            } else {" line541="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line542="            }" line543="            if (compare_001 &gt; 900) {" line544="                digit_bit(9, 1);" line545="            } else {" line546="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line547="            }" line548="            if (dispData &gt; 9000) {" line549="                digit_bit(9, 0);" line550="            } else {" line551="                digit_bit(Math.floor(dispData / 1000) % 10, 0);" line552="            }" line553="        }" line554="        else {" line555="            digit_bit(9, 3);" line556="            digit_bit(9, 2);" line557="            digit_bit(9, 1);" line558="            digit_bit(9, 0);" line559="        }" line560="    }" line561="" line562="    /**" line563="     * Set the brightness level of display at from 0 to 7" line564="     * @param level value of brightness light level" line565="     */" line566="    //% blockId=hackbit_tm1637_set_display_level block=&quot;brightness level to|%level&quot;" line567="    //% level.min=0 level.max=7" line568="    //% group=&quot;Display&quot;" line569="    //% weight=58" line570="    export function digit_set(level: number) {" line571="        digit_brightnessLevel = level;" line572="" line573="        digit_bit(digit_buf[0], 0x00);" line574="        digit_bit(digit_buf[1], 0x01);" line575="        digit_bit(digit_buf[2], 0x02);" line576="        digit_bit(digit_buf[3], 0x03);" line577="    }" line578="" line579="    /**" line580="     * Show a single number from 0 to 9 at a specified digit of Grove - 4-Digit Display" line581="     * @param dispData value of number" line582="     * @param bitAddr value of bit number" line583="     */" line584="    //% blockId=grove_tm1637_display_bit block=&quot;%strip|show single number|%dispData|at digit|%bitAddr&quot;" line585="    //% dispData.min=0 dispData.max=9" line586="    //% bitAddr.min=0 bitAddr.max=3" line587="    //% group=&quot;Display&quot;" line588="    //% advanced=true" line589="    export function digit_bit(dispData: number, bitAddr: number) {" line590="        if ((dispData == 0x7f) || ((dispData &lt;= 9) &amp;&amp; (bitAddr &lt;= 3))) {" line591="            let segData = 0;" line592="" line593="            segData = digit_coding(dispData);" line594="            digit_start();" line595="            digit_writeByte(0x44);" line596="            digit_stop();" line597="            digit_start();" line598="            digit_writeByte(bitAddr | 0xc0);" line599="            digit_writeByte(segData);" line600="            digit_stop();" line601="            digit_start();" line602="            digit_writeByte(0x88 + digit_brightnessLevel);" line603="            digit_stop();" line604="" line605="            digit_buf[bitAddr] = dispData;" line606="        }" line607="    }" line608="" line609="    /**" line610="     * Turn on or off the colon point on Grove - 4-Digit Display" line611="     * @param pointEn value of point switch" line612="     */" line613="    //% blockId=grove_tm1637_display_point block=&quot;%strip|turn|%point|colon point&quot;" line614="    //% group=&quot;Display&quot;" line615="    //% advanced=true" line616="    export function digit_point(point: boolean) {" line617="        digit_pointFlag = point;" line618="" line619="        digit_bit(digit_buf[0], 0x00);" line620="        digit_bit(digit_buf[1], 0x01);" line621="        digit_bit(digit_buf[2], 0x02);" line622="        digit_bit(digit_buf[3], 0x03);" line623="    }" line624="" line625="    /**" line626="     * Clear the display" line627="     */" line628="    //% blockId=grove_tm1637_display_clear block=&quot;%strip|clear&quot;" line629="    //% group=&quot;Display&quot;" line630="    //% advanced=true" line631="    export function digit_clear() {" line632="        digit_bit(0x7f, 0x00);" line633="        digit_bit(0x7f, 0x01);" line634="        digit_bit(0x7f, 0x02);" line635="        digit_bit(0x7f, 0x03);" line636="    }" line637="" line638="    /*" line639="     * Private functions" line640="     */" line641="    function swap16(val: NumberFormat.UInt16BE) {" line642="        return ((val &amp; 0xFF) &lt;&lt; 8)" line643="            | ((val &gt;&gt; 8) &amp; 0xFF);" line644="    }" line645="" line646="    function setDir(motor: Motors, dir: MotorDirection): void {" line647="        switch (motor) {" line648="            case Motors.Motor1: //gauche" line649="                _dir_left = dir;" line650="                break" line651="            case Motors.Motor2: //droit" line652="                _dir_right = dir;" line653="                break" line654="            case Motors.MotorFull: //droit" line655="                _dir_left = dir;" line656="                _dir_right = dir;" line657="                break" line658="        }" line659="    }" line660="" line661="    function setSpeed(motor: Motors, speed: number): void {" line662="        let corrected_speed = Math.min(Math.map(speed, 0, 100, 0, 1023), 1023);" line663="        switch (motor) {" line664="            case Motors.Motor1:" line665="                _speed_left = corrected_speed;" line666="                break" line667="            case Motors.Motor2:" line668="                _speed_right = corrected_speed;" line669="                break" line670="            case Motors.MotorFull:" line671="                _speed_left = corrected_speed;" line672="                _speed_right = corrected_speed;" line673="                break" line674="        }" line675="    }" line676="" line677="    function setMotors(): void {" line678="        if (_dir_right == 1) {" line679="            pins.digitalWritePin(DigitalPin.P15, 0);" line680="            pins.analogWritePin(AnalogPin.P16, _speed_right);" line681="        } else if (_dir_right == 2) {" line682="            pins.analogWritePin(AnalogPin.P15, _speed_right);" line683="            pins.digitalWritePin(DigitalPin.P16, 0);" line684="        } else {" line685="            pins.digitalWritePin(DigitalPin.P15, 0);" line686="            pins.digitalWritePin(DigitalPin.P16, 0);" line687="        }" line688="        if (_dir_left == 1) {" line689="            pins.digitalWritePin(DigitalPin.P13, 0);" line690="            pins.analogWritePin(AnalogPin.P14, _speed_left);" line691="        } else if (_dir_left == 2) {" line692="            pins.analogWritePin(AnalogPin.P13, _speed_left);" line693="            pins.digitalWritePin(DigitalPin.P14, 0);" line694="        } else {" line695="            pins.digitalWritePin(DigitalPin.P13, 0);" line696="            pins.digitalWritePin(DigitalPin.P14, 0);" line697="        }" line698="    }" line699="" line700="    function digit_writeByte(wrData: number) {" line701="        for (let i = 0; i &lt; 8; i++) {" line702="            pins.digitalWritePin(digit_clkPin, 0);" line703="            if (wrData &amp; 0x01) pins.digitalWritePin(digit_dataPin, 1);" line704="            else pins.digitalWritePin(digit_dataPin, 0);" line705="            wrData &gt;&gt;= 1;" line706="            pins.digitalWritePin(digit_clkPin, 1);" line707="        }" line708="" line709="        pins.digitalWritePin(digit_clkPin, 0); // Wait for ACK" line710="        pins.digitalWritePin(digit_dataPin, 1);" line711="        pins.digitalWritePin(digit_clkPin, 1);" line712="    }" line713="" line714="    function digit_start() {" line715="        pins.digitalWritePin(digit_clkPin, 1);" line716="        pins.digitalWritePin(digit_dataPin, 1);" line717="        pins.digitalWritePin(digit_dataPin, 0);" line718="        pins.digitalWritePin(digit_clkPin, 0);" line719="    }" line720="" line721="    function digit_stop() {" line722="        pins.digitalWritePin(digit_clkPin, 0);" line723="        pins.digitalWritePin(digit_dataPin, 0);" line724="        pins.digitalWritePin(digit_clkPin, 1);" line725="        pins.digitalWritePin(digit_dataPin, 1);" line726="    }" line727="" line728="    function digit_coding(dispData: number): number {" line729="        let pointData = 0;" line730="" line731="        if (digit_pointFlag == true) pointData = 0x80;" line732="        else if (digit_pointFlag == false) pointData = 0;" line733="" line734="        if (dispData == 0x7f) dispData = 0x00 + pointData;" line735="        else dispData = TubeTab[dispData] + pointData;" line736="" line737="        return dispData;" line738="    }" line739="" line740="    function paj7620WriteReg(addr: number, cmd: number) {" line741="        let buf: Buffer = pins.createBuffer(2);" line742="" line743="        buf[0] = addr;" line744="        buf[1] = cmd;" line745="" line746="        pins.i2cWriteBuffer(0x73, buf, false);" line747="    }" line748="" line749="    function paj7620ReadReg(addr: number): number {" line750="        let buf2: Buffer = pins.createBuffer(1);" line751="" line752="        buf2[0] = addr;" line753="" line754="        pins.i2cWriteBuffer(0x73, buf2, false);" line755="" line756="        buf2 = pins.i2cReadBuffer(0x73, 1, false);" line757="" line758="        return buf2[0];" line759="    }" line760="" line761="    function paj7620SelectBank(bank: number) {" line762="        if (bank == 0) paj7620WriteReg(0xEF, 0);" line763="        else if (bank == 1) paj7620WriteReg(0xEF, 1);" line764="    }" line765="" line766="    function paj7620Init() {" line767="        let temp = 0;" line768="" line769="        paj7620SelectBank(0);" line770="" line771="        temp = paj7620ReadReg(0);" line772="        if (temp == 0x20) {" line773="            for (let j = 0; j &lt; 438; j += 2) {" line774="                paj7620WriteReg(initRegisterArray[j], initRegisterArray[j + 1]);" line775="            }" line776="        }" line777="" line778="        paj7620SelectBank(0);" line779="    }" line780="}" numlines="781"></mutation></block></statement></block></xml>