<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="JP~0b6M$.$}Dfj=6yVzN" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="mAQ(myqMicEa)WIqnU7n" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace hackbit {" line1="    const initRegisterArray: number[] = [" line2="        0xEF, 0x00, 0x32, 0x29, 0x33, 0x01, 0x34, 0x00, 0x35, 0x01, 0x36, 0x00, 0x37, 0x07, 0x38, 0x17," line3="        0x39, 0x06, 0x3A, 0x12, 0x3F, 0x00, 0x40, 0x02, 0x41, 0xFF, 0x42, 0x01, 0x46, 0x2D, 0x47, 0x0F," line4="        0x48, 0x3C, 0x49, 0x00, 0x4A, 0x1E, 0x4B, 0x00, 0x4C, 0x20, 0x4D, 0x00, 0x4E, 0x1A, 0x4F, 0x14," line5="        0x50, 0x00, 0x51, 0x10, 0x52, 0x00, 0x5C, 0x02, 0x5D, 0x00, 0x5E, 0x10, 0x5F, 0x3F, 0x60, 0x27," line6="        0x61, 0x28, 0x62, 0x00, 0x63, 0x03, 0x64, 0xF7, 0x65, 0x03, 0x66, 0xD9, 0x67, 0x03, 0x68, 0x01," line7="        0x69, 0xC8, 0x6A, 0x40, 0x6D, 0x04, 0x6E, 0x00, 0x6F, 0x00, 0x70, 0x80, 0x71, 0x00, 0x72, 0x00," line8="        0x73, 0x00, 0x74, 0xF0, 0x75, 0x00, 0x80, 0x42, 0x81, 0x44, 0x82, 0x04, 0x83, 0x20, 0x84, 0x20," line9="        0x85, 0x00, 0x86, 0x10, 0x87, 0x00, 0x88, 0x05, 0x89, 0x18, 0x8A, 0x10, 0x8B, 0x01, 0x8C, 0x37," line10="        0x8D, 0x00, 0x8E, 0xF0, 0x8F, 0x81, 0x90, 0x06, 0x91, 0x06, 0x92, 0x1E, 0x93, 0x0D, 0x94, 0x0A," line11="        0x95, 0x0A, 0x96, 0x0C, 0x97, 0x05, 0x98, 0x0A, 0x99, 0x41, 0x9A, 0x14, 0x9B, 0x0A, 0x9C, 0x3F," line12="        0x9D, 0x33, 0x9E, 0xAE, 0x9F, 0xF9, 0xA0, 0x48, 0xA1, 0x13, 0xA2, 0x10, 0xA3, 0x08, 0xA4, 0x30," line13="        0xA5, 0x19, 0xA6, 0x10, 0xA7, 0x08, 0xA8, 0x24, 0xA9, 0x04, 0xAA, 0x1E, 0xAB, 0x1E, 0xCC, 0x19," line14="        0xCD, 0x0B, 0xCE, 0x13, 0xCF, 0x64, 0xD0, 0x21, 0xD1, 0x0F, 0xD2, 0x88, 0xE0, 0x01, 0xE1, 0x04," line15="        0xE2, 0x41, 0xE3, 0xD6, 0xE4, 0x00, 0xE5, 0x0C, 0xE6, 0x0A, 0xE7, 0x00, 0xE8, 0x00, 0xE9, 0x00," line16="        0xEE, 0x07, 0xEF, 0x01, 0x00, 0x1E, 0x01, 0x1E, 0x02, 0x0F, 0x03, 0x10, 0x04, 0x02, 0x05, 0x00," line17="        0x06, 0xB0, 0x07, 0x04, 0x08, 0x0D, 0x09, 0x0E, 0x0A, 0x9C, 0x0B, 0x04, 0x0C, 0x05, 0x0D, 0x0F," line18="        0x0E, 0x02, 0x0F, 0x12, 0x10, 0x02, 0x11, 0x02, 0x12, 0x00, 0x13, 0x01, 0x14, 0x05, 0x15, 0x07," line19="        0x16, 0x05, 0x17, 0x07, 0x18, 0x01, 0x19, 0x04, 0x1A, 0x05, 0x1B, 0x0C, 0x1C, 0x2A, 0x1D, 0x01," line20="        0x1E, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x25, 0x01, 0x26, 0x00, 0x27, 0x39, 0x28, 0x7F," line21="        0x29, 0x08, 0x30, 0x03, 0x31, 0x00, 0x32, 0x1A, 0x33, 0x1A, 0x34, 0x07, 0x35, 0x07, 0x36, 0x01," line22="        0x37, 0xFF, 0x38, 0x36, 0x39, 0x07, 0x3A, 0x00, 0x3E, 0xFF, 0x3F, 0x00, 0x40, 0x77, 0x41, 0x40," line23="        0x42, 0x00, 0x43, 0x30, 0x44, 0xA0, 0x45, 0x5C, 0x46, 0x00, 0x47, 0x00, 0x48, 0x58, 0x4A, 0x1E," line24="        0x4B, 0x1E, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0xA0, 0x4F, 0x80, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00," line25="        0x53, 0x00, 0x54, 0x00, 0x57, 0x80, 0x59, 0x10, 0x5A, 0x08, 0x5B, 0x94, 0x5C, 0xE8, 0x5D, 0x08," line26="        0x5E, 0x3D, 0x5F, 0x99, 0x60, 0x45, 0x61, 0x40, 0x63, 0x2D, 0x64, 0x02, 0x65, 0x96, 0x66, 0x00," line27="        0x67, 0x97, 0x68, 0x01, 0x69, 0xCD, 0x6A, 0x01, 0x6B, 0xB0, 0x6C, 0x04, 0x6D, 0x2C, 0x6E, 0x01," line28="        0x6F, 0x32, 0x71, 0x00, 0x72, 0x01, 0x73, 0x35, 0x74, 0x00, 0x75, 0x33, 0x76, 0x31, 0x77, 0x01," line29="        0x7C, 0x84, 0x7D, 0x03, 0x7E, 0x01" line30="    ];" line31="" line32="    export enum MotorDirection {" line33="        //% block=&quot;Forward&quot;" line34="        Forward = 1," line35="        //% block=&quot;Backward&quot;" line36="        Reverse = 2," line37="        //% block=&quot;Stop&quot;" line38="        Stop = 0" line39="    }" line40="" line41="    export enum OnOff {" line42="        //% block=&quot;On&quot;" line43="        On = 1," line44="        //% block=&quot;Off&quot;" line45="        Off = 0" line46="    }" line47="" line48="    export enum BP {" line49="        //% block=&quot;BPA&quot;" line50="        BPA = 1," line51="        //% block=&quot;BPB&quot;" line52="        BPB = 0" line53="    }" line54="" line55="    export enum RobotDirection {" line56="        //% block=&quot;Forward&quot;" line57="        Forward," line58="        //% block=&quot;Backward&quot;" line59="        Reverse," line60="        //% block=&quot;Turn Right&quot;" line61="        TurnRigh," line62="        //% block=&quot;Turn Left&quot;" line63="        TurnLef," line64="        //% block=&quot;Rotate Right&quot;" line65="        RotateRight," line66="        //% block=&quot;Rotate Left&quot;" line67="        RotateLef," line68="        //% block=&quot;Stop&quot;" line69="        Stop" line70="    }" line71="" line72="    export enum Motors {" line73="        //%blockId=A4_Robot_Driver_motor_one" line74="        //% block=&quot;left motor&quot;" line75="        Motor1," line76="        //%blockId=A4_Robot_Driver_motor_two" line77="        //% block=&quot;right motor&quot;" line78="        Motor2," line79="        //%blockId=A4_Robot_Driver_motor_full" line80="        //% block=&quot;left and right motor&quot;" line81="        MotorFull" line82="    }" line83="" line84="    export enum Color {" line85="        //% block=&quot;Red&quot;" line86="        Red," line87="        //% block=&quot;Green&quot;" line88="        Green," line89="        //% block=&quot;Blue&quot;" line90="        Blue," line91="        //% block=&quot;Clear&quot;" line92="        Clear" line93="    }" line94="" line95="    export enum GroveGesture {" line96="        //% block=None" line97="        None = 0," line98="        //% block=Right" line99="        Right = 1," line100="        //% block=Left" line101="        Left = 2," line102="        //% block=Up" line103="        Up = 3," line104="        //% block=Down" line105="        Down = 4," line106="        //% block=Forward" line107="        Forward = 5," line108="        //% block=Backward" line109="        Backward = 6," line110="        //% block=Clockwise" line111="        Clockwise = 7," line112="        //% block=Anticlockwise" line113="        Anticlockwise = 8," line114="        //% block=Wave" line115="        Wave = 9" line116="    }" line117="" line118="    export let _speed_left = 700; //1023 = 100% speed" line119="    export let _speed_right = 700;" line120="    export let _dir_right = 1; //0 = stop, 1 = forward, 2 = backward" line121="    export let _dir_left = 1;" line122="    export let identifiant = 0;" line123="    export let grovegestureinit = 0;" line124="" line125="    let TubeTab: number[] = [" line126="        0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07," line127="        0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71" line128="    ];" line129="" line130="    export let digit_clkPin: DigitalPin;" line131="    export let digit_dataPin: DigitalPin;" line132="    export let digit_brightnessLevel: number;" line133="    export let digit_pointFlag: boolean;" line134="    export let digit_buf: Buffer;" line135="" line136="    let wifi_connected: boolean = false" line137="    let thingspeak_connected: boolean = false" line138="    let last_upload_successful: boolean = false" line139="" line140="    /**" line141="     * Control Robot speed [0-100%]" line142="     * @param dir direction" line143="     * @param speed speed in %" line144="     */" line145="    //% blockId=RobotDriverRobotMove" line146="    //% block=&quot;move %dir| speed %speed&quot;" line147="    //% speed.min=0 speed.max=100" line148="    //% parts=&quot;RobotDriver&quot; advanced=false" line149="    //% speed.defl=75" line150="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#EA5532" line151="    export function robotMove(dir: RobotDirection, speed: number): void {" line152="        setSpeed(Motors.MotorFull, speed);" line153="        switch (dir) {" line154="            case RobotDirection.Forward:" line155="                setDir(Motors.MotorFull, MotorDirection.Forward);" line156="                break" line157="            case RobotDirection.Reverse:" line158="                setDir(Motors.MotorFull, MotorDirection.Reverse);" line159="                break" line160="            case RobotDirection.RotateRight:" line161="                setDir(Motors.Motor1, MotorDirection.Forward);" line162="                setDir(Motors.Motor2, MotorDirection.Reverse);" line163="                break" line164="            case RobotDirection.RotateLef:" line165="                setDir(Motors.Motor1, MotorDirection.Reverse);" line166="                setDir(Motors.Motor2, MotorDirection.Forward);" line167="                break" line168="            case RobotDirection.TurnRigh:" line169="                setDir(Motors.Motor1, MotorDirection.Forward);" line170="                setDir(Motors.Motor2, MotorDirection.Stop);" line171="                break" line172="            case RobotDirection.TurnLef:" line173="                setDir(Motors.Motor1, MotorDirection.Stop);" line174="                setDir(Motors.Motor2, MotorDirection.Forward);" line175="                break" line176="            case RobotDirection.Stop:" line177="                setDir(Motors.MotorFull, MotorDirection.Stop);" line178="                break" line179="        }" line180="        setMotors();" line181="    }" line182="" line183="" line184="    /**" line185="     * Change the motor direction" line186="     * @param motor selection (left, right)" line187="     * @param dir rotation direction (forward, backward)" line188="     */" line189="    //% blockId=RobotDrivermotordir" line190="    //% block=&quot;set %motor| %dir&quot;" line191="    //% parts=&quot;RobotDriver&quot; advanced=false" line192="    //% motor.defl=MotorFull" line193="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#EA5532" line194="    export function motorDir(motor: Motors, dir: MotorDirection): void {" line195="        setDir(motor, dir);" line196="        setMotors();" line197="    }" line198="" line199="    /**" line200="     * Change the motor speed [0-100%]" line201="     * @param motor selection (left, right)" line202="     * @param new speed (0-100%)" line203="     */" line204="" line205="    //% blockId=robotdrivermotorspeed" line206="    //% block=&quot;set %motor| to %speed %&quot;" line207="    //% speed.min=0 speed.max=100" line208="    //% parts=&quot;A4_Robot_Driver&quot; advanced=false" line209="    //% speed.defl=75" line210="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#EA5532" line211="    export function motorSpeed(motor: Motors, speed: number): void {" line212="        setSpeed(motor, speed);" line213="        setMotors();" line214="    }" line215="" line216="    /**" line217="     * Stop both motors" line218="    */" line219="    //% blockId=RobotDriverRobotStop" line220="    //% block=&quot;stop both motors&quot;" line221="    //% subcategory=Motor  group=&quot;Motors DC&quot; color=#EA5532" line222="    export function motorStop(): void {" line223="        robotMove(hackbit.RobotDirection.Stop, 0)" line224="    }" line225="" line226="    /**" line227="     * Set the servomotor position [0-180deg]" line228="     * @param pin servomotor pin (right or left)" line229="     */" line230="    //% blockId=RobotDriverservodegrees" line231="    //% block=&quot;servomotor |%pin| to |%angle| degree&quot;" line232="    //% parts=&quot;RobotDriver&quot; advanced=false" line233="    //% angle.shadow=&quot;protractorPicker&quot;" line234="    //% angle.defl=90" line235="    //% subcategory=Motor  group=&quot;Servo Motors&quot; color=#EA5532" line236="    export function setServoMotor(pin: AnalogPin, angle: number): void {" line237="        pins.servoWritePin(pin, Math.constrain(angle, 0, 180));" line238="    }" line239="" line240="    /**" line241="     * get distance from ultrasonic range sensor [cm]" line242="     * @param pin Input pin" line243="     */" line244="    //% blockId=RobotDriverultrasonic_cm " line245="    //% block=&quot;ultrasonic distance|%name| (cm)&quot;" line246="    //% name.fieldEditor=&quot;gridpicker&quot; " line247="    //% name.fieldOptions.columns=5" line248="    //% name.fieldOptions.tooltips=&quot;false&quot;" line249="    //% name.fieldOptions.width=&quot;0&quot;" line250="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#EA5532" line251="    export function measureDistanceCentimeter(name: DigitalPin): number {" line252="        let duration = 0;" line253="        let distance = 0;" line254="        pins.digitalWritePin(name, 0); //make sure pin is low" line255="        control.waitMicros(2);" line256="        pins.digitalWritePin(name, 1); //send echo" line257="        control.waitMicros(20);" line258="        pins.digitalWritePin(name, 0);" line259="        duration = pins.pulseIn(name, PulseValue.High, 50000); // Max duration 50 ms - receive echo" line260="        distance = duration * 153 / 29 / 2 / 100;" line261="        Math.constrain(distance, 0, 500);" line262="        return distance;" line263="    }" line264="" line265="    /**" line266="     * Get line sensor state [0-1]" line267="    */" line268="    //% blockId=hackbitLineRead" line269="    //% block=&quot;line sensor |%pin|&quot;" line270="    //% subcategory=Sensor  group=&quot;Digital&quot; color=#EA5532        " line271="    export function detectline(pin: DigitalPin): number {" line272="        return pins.digitalReadPin(pin);" line273="    }" line274="" line275="    /**" line276="     * Get analog potentiometer value [0-1023]" line277="    */" line278="    //% blockId=hackbitPotargRead" line279="    //% block=&quot;potentiometer |%pin|&quot;" line280="    //% subcategory=Input  group=&quot;Analog&quot; color=#EA5532" line281="    export function potarValue(pin: AnalogPin): number {" line282="        return pins.analogReadPin(pin);" line283="    }" line284="" line285="    /**" line286="     * Get collision sensor state [0-1]" line287="    */" line288="    //% blockId=hackbitCollisionRead" line289="    //% block=&quot;collision sensor |%pin|&quot;" line290="    //% subcategory=Input  group=&quot;Digital&quot; color=#EA5532    " line291="    export function collisionSensor(pin: BP): boolean {" line292="        if (pin)" line293="            return input.buttonIsPressed(Button.A);" line294="        return input.buttonIsPressed(Button.B);" line295="    }" line296="" line297="    /**" line298="     * Get button state [0-1]" line299="    */" line300="    //% blockId=hackbitButtonRead" line301="    //% block=&quot;button |%pin|&quot;" line302="    //% subcategory=Input  group=&quot;Digital&quot; color=#EA5532    " line303="    export function buttonState(pin: DigitalPin): number {" line304="        return pins.digitalReadPin(pin);" line305="    }" line306="" line307="    /**" line308="     * Set Led state" line309="    */" line310="    //% blockId=hackbitLedSet" line311="    //% block=&quot;led |%pin| to |%state|&quot;" line312="    //% state.min=0 state.max=1" line313="    //% subcategory=Display  group=&quot;Digital&quot; color=#EA5532    " line314="    export function ledState(pin: DigitalPin, state: OnOff): void {" line315="        pins.digitalWritePin(pin, state);" line316="    }" line317="" line318="    /**" line319="    * Get color from I2C Grove Color Sensor v1.3 or v2.0" line320="    * [0;65534]" line321="    * @param selected color" line322="    */" line323="    //% blockId=&quot;grovecolorsensorgetcolor&quot; " line324="    //% block=&quot;color %Color&quot;" line325="    //% block.loc.fr=&quot;Valeur de la couleur %Color du capteur de couleur grove&quot;" line326="    //% jsdoc = &quot;Grab sensor value from grove color sensor&quot;" line327="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532    " line328="" line329="    export function color(col: Color): NumberFormat.UInt16BE {" line330="        let nums, red, green, blue, clear: number;" line331="" line332="        if (identifiant == 0) {   // No sensor previously detected" line333="            pins.i2cWriteNumber(57, 132, NumberFormat.UInt8BE, false);" line334="            nums = pins.i2cReadNumber(57, NumberFormat.UInt8BE, false);" line335="            if (nums == 17) {     // Grove Sensor v1.3 detected" line336="                identifiant = 1;" line337="                pins.i2cWriteNumber(57, 129, NumberFormat.UInt8BE, false);" line338="                pins.i2cWriteNumber(57, 0, NumberFormat.UInt8BE, true);" line339="                pins.i2cWriteNumber(57, 135, NumberFormat.UInt8BE, false);" line340="                pins.i2cWriteNumber(57, 48, NumberFormat.UInt8BE, true);" line341="                pins.i2cWriteNumber(57, 128, NumberFormat.UInt8BE, false);" line342="                pins.i2cWriteNumber(57, 3, NumberFormat.UInt8BE, true);" line343="                basic.pause(50);" line344="            } else {" line345="                pins.i2cWriteNumber(41, 146, NumberFormat.UInt8BE, false);" line346="                nums = pins.i2cReadNumber(41, NumberFormat.UInt8BE, false);" line347="                if (nums == 68) {     // Grove Sensor v2 detected " line348="                    identifiant = 2;" line349="                    pins.i2cWriteNumber(41, 129, NumberFormat.UInt8BE, false);" line350="                    pins.i2cWriteNumber(41, 249, NumberFormat.UInt8BE, true);" line351="                    pins.i2cWriteNumber(41, 143, NumberFormat.UInt8BE, false);" line352="                    pins.i2cWriteNumber(41, 2, NumberFormat.UInt8BE, true);" line353="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line354="                    pins.i2cWriteNumber(41, 1, NumberFormat.UInt8BE, true);" line355="                    basic.pause(50);" line356="                    pins.i2cWriteNumber(41, 128, NumberFormat.UInt8BE, false);" line357="                    pins.i2cWriteNumber(41, 3, NumberFormat.UInt8BE, true);" line358="                    basic.pause(500);" line359="                }" line360="            }" line361="        }" line362="" line363="        if (identifiant == 1) {    // Grove Sensor v1.3 detected" line364="            switch (col) {" line365="                case Color.Red:" line366="                    pins.i2cWriteNumber(57, 210, NumberFormat.UInt8BE, false);" line367="                    red = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line368="                    return swap16(red)" line369="                    break" line370="                case Color.Green:" line371="                    pins.i2cWriteNumber(57, 208, NumberFormat.UInt8BE, false);" line372="                    green = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line373="                    return swap16(green)" line374="                    break" line375="                case Color.Blue:" line376="                    pins.i2cWriteNumber(57, 212, NumberFormat.UInt8BE, false);" line377="                    blue = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line378="                    return swap16(blue)" line379="                    break" line380="                case Color.Clear:" line381="                    pins.i2cWriteNumber(57, 214, NumberFormat.UInt8BE, false);" line382="                    clear = pins.i2cReadNumber(57, NumberFormat.UInt16BE, true);" line383="                    return swap16(clear)" line384="                    break" line385="            }" line386="        }" line387="        else if (identifiant == 2) {" line388="            switch (col) {" line389="                case Color.Red:" line390="                    pins.i2cWriteNumber(41, 150, NumberFormat.UInt8BE, false);" line391="                    red = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line392="                    return swap16(red)" line393="                    break" line394="                case Color.Green:" line395="                    pins.i2cWriteNumber(41, 152, NumberFormat.UInt8BE, false);" line396="                    green = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line397="                    return swap16(green)" line398="                    break" line399="                case Color.Blue:" line400="                    pins.i2cWriteNumber(41, 154, NumberFormat.UInt8BE, false);" line401="                    blue = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line402="                    return swap16(blue)" line403="                    break" line404="                case Color.Clear:" line405="                    pins.i2cWriteNumber(41, 148, NumberFormat.UInt8BE, false);" line406="                    clear = pins.i2cReadNumber(41, NumberFormat.UInt16BE, true);" line407="                    return swap16(clear)" line408="                    break" line409="            }" line410="            return 0;" line411="        }" line412="        return 0;" line413="    }" line414="" line415="    /**" line416="     * Detect and recognize the gestures from Grove - Gesture" line417="     * None:0" line418="     * Right:1" line419="     * Left:2" line420="     * Up:3" line421="     * Down:4" line422="     * Forward:5" line423="     * Backward:6" line424="     * Clockwise:7" line425="     * Anticlockwise:8" line426="     * Wave:9" line427="     */" line428="    //% blockId=hackbitGroveGesture" line429="    //% subcategory=Sensor  group=&quot;IIC&quot; color=#EA5532    " line430="    export function grove_gesture_reads(): number {" line431="        let data = 0, result = 0;" line432="" line433="        if (grovegestureinit == 0) {" line434="            paj7620Init();" line435="            basic.pause(200);" line436="            grovegestureinit = 1;" line437="        }" line438="" line439="        data = paj7620ReadReg(0x43);" line440="        switch (data) {" line441="            case 0x01:" line442="                result = GroveGesture.Right;" line443="                break;" line444="" line445="            case 0x02:" line446="                result = GroveGesture.Left;" line447="                break;" line448="" line449="            case 0x04:" line450="                result = GroveGesture.Up;" line451="                break;" line452="" line453="            case 0x08:" line454="                result = GroveGesture.Down;" line455="                break;" line456="" line457="            case 0x10:" line458="                result = GroveGesture.Forward;" line459="                break;" line460="" line461="            case 0x20:" line462="                result = GroveGesture.Backward;" line463="                break;" line464="" line465="            case 0x40:" line466="                result = GroveGesture.Clockwise;" line467="                break;" line468="" line469="            case 0x80:" line470="                result = GroveGesture.Anticlockwise;" line471="                break;" line472="" line473="            default:" line474="                data = paj7620ReadReg(0x44);" line475="                if (data == 0x01)" line476="                    result = GroveGesture.Wave;" line477="                break;" line478="        }" line479="        return result;" line480="    }" line481="" line482="    /**" line483="     * Create a new driver Grove - 4-Digit Display" line484="     * @param clkPin value of clk pin number" line485="     * @param dataPin value of data pin number" line486="     */" line487="    //% blockId=hackbit_tm1637_create block=&quot;4-Digit Display at|%clkPin|and|%dataPin&quot;" line488="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#EA5532    " line489="    //% weight=60" line490="    export function digit_createDisplay(clkPin: DigitalPin, dataPin: DigitalPin): void {" line491="        digit_buf = pins.createBuffer(4);" line492="        digit_clkPin = clkPin;" line493="        digit_dataPin = dataPin;" line494="        digit_brightnessLevel = 0;" line495="        digit_pointFlag = false;" line496="        digit_clear();" line497="    }" line498="" line499="    /**" line500="    * Show a 4 digits number on display" line501="    * @param dispData value of number" line502="    */" line503="    //% blockId=hackbit_tm1637_display_number block=&quot;show number|%dispData&quot;" line504="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#EA5532    " line505="    //% weight=59" line506="    export function digit_show(dispData: number) {" line507="        let compare_01: number = dispData % 100;" line508="        let compare_001: number = dispData % 1000;" line509="" line510="        if (dispData &lt; 10) {" line511="            digit_bit(dispData, 3);" line512="            digit_bit(0x7f, 2);" line513="            digit_bit(0x7f, 1);" line514="            digit_bit(0x7f, 0);" line515="        }" line516="        else if (dispData &lt; 100) {" line517="            digit_bit(dispData % 10, 3);" line518="            if (dispData &gt; 90) {" line519="                digit_bit(9, 2);" line520="            } else {" line521="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line522="            }" line523="" line524="            digit_bit(0x7f, 1);" line525="            digit_bit(0x7f, 0);" line526="        }" line527="        else if (dispData &lt; 1000) {" line528="            digit_bit(dispData % 10, 3);" line529="            if (compare_01 &gt; 90) {" line530="                digit_bit(9, 2);" line531="            } else {" line532="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line533="            }" line534="            if (compare_001 &gt; 900) {" line535="                digit_bit(9, 1);" line536="            } else {" line537="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line538="            }" line539="            digit_bit(0x7f, 0);" line540="        }" line541="        else if (dispData &lt; 10000) {" line542="            digit_bit(dispData % 10, 3);" line543="            if (compare_01 &gt; 90) {" line544="                digit_bit(9, 2);" line545="            } else {" line546="                digit_bit(Math.floor(dispData / 10) % 10, 2);" line547="            }" line548="            if (compare_001 &gt; 900) {" line549="                digit_bit(9, 1);" line550="            } else {" line551="                digit_bit(Math.floor(dispData / 100) % 10, 1);" line552="            }" line553="            if (dispData &gt; 9000) {" line554="                digit_bit(9, 0);" line555="            } else {" line556="                digit_bit(Math.floor(dispData / 1000) % 10, 0);" line557="            }" line558="        }" line559="        else {" line560="            digit_bit(9, 3);" line561="            digit_bit(9, 2);" line562="            digit_bit(9, 1);" line563="            digit_bit(9, 0);" line564="        }" line565="    }" line566="" line567="    /**" line568="     * Set the brightness level of display at from 0 to 7" line569="     * @param level value of brightness light level" line570="     */" line571="    //% blockId=hackbit_tm1637_set_display_level block=&quot;brightness level to|%level&quot;" line572="    //% level.min=0 level.max=7" line573="    //% weight=58" line574="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#EA5532    " line575="    export function digit_set(level: number) {" line576="        digit_brightnessLevel = level;" line577="" line578="        digit_bit(digit_buf[0], 0x00);" line579="        digit_bit(digit_buf[1], 0x01);" line580="        digit_bit(digit_buf[2], 0x02);" line581="        digit_bit(digit_buf[3], 0x03);" line582="    }" line583="" line584="    /**" line585="     * Show a single number from 0 to 9 at a specified digit of Grove - 4-Digit Display" line586="     * @param dispData value of number" line587="     * @param bitAddr value of bit number" line588="     */" line589="    //% blockId=grove_tm1637_display_bit block=&quot;%strip|show single number|%dispData|at digit|%bitAddr&quot;" line590="    //% dispData.min=0 dispData.max=9" line591="    //% bitAddr.min=0 bitAddr.max=3" line592="    //% advanced=false" line593="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#EA5532    " line594="    export function digit_bit(dispData: number, bitAddr: number) {" line595="        if ((dispData == 0x7f) || ((dispData &lt;= 9) &amp;&amp; (bitAddr &lt;= 3))) {" line596="            let segData = 0;" line597="" line598="            segData = digit_coding(dispData);" line599="            digit_start();" line600="            digit_writeByte(0x44);" line601="            digit_stop();" line602="            digit_start();" line603="            digit_writeByte(bitAddr | 0xc0);" line604="            digit_writeByte(segData);" line605="            digit_stop();" line606="            digit_start();" line607="            digit_writeByte(0x88 + digit_brightnessLevel);" line608="            digit_stop();" line609="" line610="            digit_buf[bitAddr] = dispData;" line611="        }" line612="    }" line613="" line614="    /**" line615="     * Turn on or off the colon point on Grove - 4-Digit Display" line616="     * @param pointEn value of point switch" line617="     */" line618="    //% blockId=grove_tm1637_display_point block=&quot;%strip|turn|%point|colon point&quot;" line619="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#EA5532    " line620="    //% advanced=false" line621="    export function digit_point(point: boolean) {" line622="        digit_pointFlag = point;" line623="" line624="        digit_bit(digit_buf[0], 0x00);" line625="        digit_bit(digit_buf[1], 0x01);" line626="        digit_bit(digit_buf[2], 0x02);" line627="        digit_bit(digit_buf[3], 0x03);" line628="    }" line629="" line630="    /**" line631="     * Clear the display" line632="     */" line633="    //% blockId=grove_tm1637_display_clear block=&quot;%strip|clear&quot;" line634="    //% subcategory=Display  group=&quot;7-Seg&quot; color=#EA5532    " line635="    //% advanced=false" line636="    export function digit_clear() {" line637="        digit_bit(0x7f, 0x00);" line638="        digit_bit(0x7f, 0x01);" line639="        digit_bit(0x7f, 0x02);" line640="        digit_bit(0x7f, 0x03);" line641="    }" line642="" line643="    /**" line644="     * WiFi/IoT" line645="     * Initialize ESP8266 module and connect it to Wifi router" line646="     */" line647="    //% block=&quot;Initialize ESP8266|RX (Tx of micro:bit) %tx|TX (Rx of micro:bit) %rx|Baud rate %baudrate|Wifi SSID = %ssid|Wifi PW = %pw&quot;" line648="    //% tx.defl=SerialPin.P0" line649="    //% rx.defl=SerialPin.P1" line650="    //% ssid.defl=your_ssid" line651="    //% pw.defl=your_pw" line652="    //% subcategory=WiFi-IoT group=&quot;ESP8266 ThingSpeak&quot; color=#009b5b icon=&quot;\uf1eb&quot;    " line653="    //% advanced=false" line654="" line655="    export function connectWifi(tx: SerialPin, rx: SerialPin, baudrate: BaudRate, ssid: string, pw: string) {" line656="        wifi_connected = false" line657="        thingspeak_connected = false" line658="        serial.redirect(" line659="            tx," line660="            rx," line661="            baudrate" line662="        )" line663="        sendAT(&quot;AT+RESTORE&quot;, 1000) // restore to factory settings" line664="        sendAT(&quot;AT+CWMODE=1&quot;) // set to STA mode" line665="        sendAT(&quot;AT+RST&quot;, 1000) // reset" line666="        sendAT(&quot;AT+CWJAP=\&quot;&quot; + ssid + &quot;\&quot;,\&quot;&quot; + pw + &quot;\&quot;&quot;, 0) // connect to Wifi router" line667="        wifi_connected = waitResponse()" line668="        basic.pause(100)" line669="    }" line670="" line671="    /**" line672="    * Connect to ThingSpeak and upload data. It would not upload anything if it failed to connect to Wifi or ThingSpeak." line673="    */" line674="    //% block=&quot;Upload data to ThingSpeak|URL/IP = %ip|Write API key = %write_api_key|Field 1 = %n1|Field 2 = %n2|Field 3 = %n3|Field 4 = %n4|Field 5 = %n5|Field 6 = %n6|Field 7 = %n7|Field 8 = %n8&quot;" line675="    //% ip.defl=api.thingspeak.com" line676="    //% write_api_key.defl=your_write_api_key" line677="    //% subcategory=WiFi-IoT group=&quot;ESP8266 ThingSpeak&quot; color=#009b5b icon=&quot;\uf1eb&quot;    " line678="    //% advanced=false" line679="" line680="    export function connectThingSpeak(ip: string, write_api_key: string, n1: number, n2: number, n3: number, n4: number, n5: number, n6: number, n7: number, n8: number) {" line681="        if (wifi_connected &amp;&amp; write_api_key != &quot;&quot;) {" line682="            thingspeak_connected = false" line683="            sendAT(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;&quot; + ip + &quot;\&quot;,80&quot;, 0) // connect to website server" line684="            thingspeak_connected = waitResponse()" line685="            basic.pause(100)" line686="            if (thingspeak_connected) {" line687="                last_upload_successful = false" line688="                let str: string = &quot;GET /update?api_key=&quot; + write_api_key + &quot;&amp;field1=&quot; + n1 + &quot;&amp;field2=&quot; + n2 + &quot;&amp;field3=&quot; + n3 + &quot;&amp;field4=&quot; + n4 + &quot;&amp;field5=&quot; + n5 + &quot;&amp;field6=&quot; + n6 + &quot;&amp;field7=&quot; + n7 + &quot;&amp;field8=&quot; + n8" line689="                sendAT(&quot;AT+CIPSEND=&quot; + (str.length + 2))" line690="                sendAT(str, 0) // upload data" line691="                last_upload_successful = waitResponse()" line692="                basic.pause(100)" line693="            }" line694="        }" line695="    }" line696="" line697="    /**" line698="    * Wait between uploads" line699="    */" line700="    //% block=&quot;Wait %delay ms&quot;" line701="    //% delay.min=0 delay.defl=5000" line702="    //% subcategory=WiFi-IoT group=&quot;ESP8266 ThingSpeak&quot; color=#009b5b icon=&quot;\uf1eb&quot;    " line703="    //% advanced=false" line704="" line705="    export function wait(delay: number) {" line706="        if (delay &gt; 0) basic.pause(delay)" line707="    }" line708="" line709="    /**" line710="    * Check if ESP8266 successfully connected to Wifi" line711="    */" line712="    //% block=&quot;Wifi connected ?&quot;" line713="    //% subcategory=WiFi-IoT group=&quot;ESP8266 ThingSpeak&quot; color=#009b5b icon=&quot;\uf1eb&quot;    " line714="    //% advanced=false" line715="" line716="    export function isWifiConnected() {" line717="        return wifi_connected" line718="    }" line719="" line720="    /**" line721="    * Check if ESP8266 successfully connected to ThingSpeak" line722="    */" line723="    //% block=&quot;ThingSpeak connected ?&quot;" line724="    //% subcategory=WiFi-IoT group=&quot;ESP8266 ThingSpeak&quot; color=#009b5b icon=&quot;\uf1eb&quot;    " line725="    //% advanced=false" line726="" line727="    export function isThingSpeakConnected() {" line728="        return thingspeak_connected" line729="    }" line730="" line731="    /**" line732="    * Check if ESP8266 successfully uploaded data to ThingSpeak" line733="    */" line734="    //% block=&quot;Last data upload successful ?&quot;" line735="    //% subcategory=WiFi-IoT group=&quot;ESP8266 ThingSpeak&quot; color=#009b5b icon=&quot;\uf1eb&quot;    " line736="    //% advanced=false" line737="" line738="    export function isLastUploadSuccessful() {" line739="        return last_upload_successful" line740="    }" line741="" line742="    /*" line743="     * Private functions" line744="     */" line745="    function swap16(val: NumberFormat.UInt16BE) {" line746="        return ((val &amp; 0xFF) &lt;&lt; 8)" line747="            | ((val &gt;&gt; 8) &amp; 0xFF);" line748="    }" line749="" line750="    function setDir(motor: Motors, dir: MotorDirection): void {" line751="        switch (motor) {" line752="            case Motors.Motor1: //gauche" line753="                _dir_left = dir;" line754="                break" line755="            case Motors.Motor2: //droit" line756="                _dir_right = dir;" line757="                break" line758="            case Motors.MotorFull: //droit" line759="                _dir_left = dir;" line760="                _dir_right = dir;" line761="                break" line762="        }" line763="    }" line764="" line765="    function setSpeed(motor: Motors, speed: number): void {" line766="        let corrected_speed = Math.min(Math.map(speed, 0, 100, 0, 1023), 1023);" line767="        switch (motor) {" line768="            case Motors.Motor1:" line769="                _speed_left = corrected_speed;" line770="                break" line771="            case Motors.Motor2:" line772="                _speed_right = corrected_speed;" line773="                break" line774="            case Motors.MotorFull:" line775="                _speed_left = corrected_speed;" line776="                _speed_right = corrected_speed;" line777="                break" line778="        }" line779="    }" line780="" line781="    function setMotors(): void {" line782="        if (_dir_right == 1) {" line783="            pins.digitalWritePin(DigitalPin.P15, 0);" line784="            pins.analogWritePin(AnalogPin.P16, _speed_right);" line785="        } else if (_dir_right == 2) {" line786="            pins.analogWritePin(AnalogPin.P15, _speed_right);" line787="            pins.digitalWritePin(DigitalPin.P16, 0);" line788="        } else {" line789="            pins.digitalWritePin(DigitalPin.P15, 0);" line790="            pins.digitalWritePin(DigitalPin.P16, 0);" line791="        }" line792="        if (_dir_left == 1) {" line793="            pins.digitalWritePin(DigitalPin.P13, 0);" line794="            pins.analogWritePin(AnalogPin.P14, _speed_left);" line795="        } else if (_dir_left == 2) {" line796="            pins.analogWritePin(AnalogPin.P13, _speed_left);" line797="            pins.digitalWritePin(DigitalPin.P14, 0);" line798="        } else {" line799="            pins.digitalWritePin(DigitalPin.P13, 0);" line800="            pins.digitalWritePin(DigitalPin.P14, 0);" line801="        }" line802="    }" line803="" line804="    function digit_writeByte(wrData: number) {" line805="        for (let i = 0; i &lt; 8; i++) {" line806="            pins.digitalWritePin(digit_clkPin, 0);" line807="            if (wrData &amp; 0x01) pins.digitalWritePin(digit_dataPin, 1);" line808="            else pins.digitalWritePin(digit_dataPin, 0);" line809="            wrData &gt;&gt;= 1;" line810="            pins.digitalWritePin(digit_clkPin, 1);" line811="        }" line812="" line813="        pins.digitalWritePin(digit_clkPin, 0); // Wait for ACK" line814="        pins.digitalWritePin(digit_dataPin, 1);" line815="        pins.digitalWritePin(digit_clkPin, 1);" line816="    }" line817="" line818="    function digit_start() {" line819="        pins.digitalWritePin(digit_clkPin, 1);" line820="        pins.digitalWritePin(digit_dataPin, 1);" line821="        pins.digitalWritePin(digit_dataPin, 0);" line822="        pins.digitalWritePin(digit_clkPin, 0);" line823="    }" line824="" line825="    function digit_stop() {" line826="        pins.digitalWritePin(digit_clkPin, 0);" line827="        pins.digitalWritePin(digit_dataPin, 0);" line828="        pins.digitalWritePin(digit_clkPin, 1);" line829="        pins.digitalWritePin(digit_dataPin, 1);" line830="    }" line831="" line832="    function digit_coding(dispData: number): number {" line833="        let pointData = 0;" line834="" line835="        if (digit_pointFlag == true) pointData = 0x80;" line836="        else if (digit_pointFlag == false) pointData = 0;" line837="" line838="        if (dispData == 0x7f) dispData = 0x00 + pointData;" line839="        else dispData = TubeTab[dispData] + pointData;" line840="" line841="        return dispData;" line842="    }" line843="" line844="    function paj7620WriteReg(addr: number, cmd: number) {" line845="        let buf: Buffer = pins.createBuffer(2);" line846="" line847="        buf[0] = addr;" line848="        buf[1] = cmd;" line849="" line850="        pins.i2cWriteBuffer(0x73, buf, false);" line851="    }" line852="" line853="    function paj7620ReadReg(addr: number): number {" line854="        let buf2: Buffer = pins.createBuffer(1);" line855="" line856="        buf2[0] = addr;" line857="" line858="        pins.i2cWriteBuffer(0x73, buf2, false);" line859="" line860="        buf2 = pins.i2cReadBuffer(0x73, 1, false);" line861="" line862="        return buf2[0];" line863="    }" line864="" line865="    function paj7620SelectBank(bank: number) {" line866="        if (bank == 0) paj7620WriteReg(0xEF, 0);" line867="        else if (bank == 1) paj7620WriteReg(0xEF, 1);" line868="    }" line869="" line870="    function paj7620Init() {" line871="        let temp = 0;" line872="" line873="        paj7620SelectBank(0);" line874="" line875="        temp = paj7620ReadReg(0);" line876="        if (temp == 0x20) {" line877="            for (let j = 0; j &lt; 438; j += 2) {" line878="                paj7620WriteReg(initRegisterArray[j], initRegisterArray[j + 1]);" line879="            }" line880="        }" line881="" line882="        paj7620SelectBank(0);" line883="    }" line884="" line885="    // write AT command with CR+LF ending" line886="    function sendAT(command: string, wait: number = 100) {" line887="        serial.writeString(command + &quot;\u000D\u000A&quot;)" line888="        basic.pause(wait)" line889="    }" line890="" line891="    // wait for certain response from ESP8266" line892="    function waitResponse(): boolean {" line893="        let serial_str: string = &quot;&quot;" line894="        let result2: boolean = false" line895="        let time: number = input.runningTime()" line896="        while (true) {" line897="            serial_str += serial.readString()" line898="            if (serial_str.length &gt; 200) serial_str = serial_str.substr(serial_str.length - 200)" line899="            if (serial_str.includes(&quot;OK&quot;) || serial_str.includes(&quot;ALREADY CONNECTED&quot;)) {" line900="                result2 = true" line901="                break" line902="            } else if (serial_str.includes(&quot;ERROR&quot;) || serial_str.includes(&quot;SEND FAIL&quot;)) {" line903="                break" line904="            }" line905="            if (input.runningTime() - time &gt; 30000) break" line906="        }" line907="        return result2" line908="    }" line909="" line910="" line911="}" numlines="912"></mutation></block></statement></block></xml>